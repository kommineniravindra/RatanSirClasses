[{
  "question": "Find the largest element in an array.",
  "answer": "public class LargestElement {\n\n    // Method to find the largest element in an array\n    public static int findLargest(int[] nums) {\n        // Assume the first element is the maximum\n        int max = nums[0];\n\n        // Loop through each element in the array\n        for (int num : nums) {\n            // If the current number is greater than max, update max\n            if (num > max) {\n                max = num;\n            }\n        }\n\n        // Return the largest element\n        return max;\n    }\n\n    // Main method to test the logic\n    public static void main(String[] args) {\n        // Sample array input\n        int[] arr = {3, 7, 2, 9, 5};\n\n        // Print the largest element\n        System.out.println(\"Largest: \" + findLargest(arr));\n    }\n}\n",
  "input": "[3, 7, 2, 9, 5]",
  "output": "9",
  "explanation": "We start by assuming the first element is the maximum. Then, we traverse the array element by element, comparing each with the current maximum. If a larger value is found, we update that value as  maximum. Finally, we return the maximum value.",
  "youtubeLink": "https://youtu.be/bZVIdFGX448"
},
{
    "question": "Find the second largest element in an array (without sorting).",
    "answer": "public class SecondLargestElement {\n\n    // Method to find the second largest element\n    public static int findSecondLargest(int[] nums) {\n        // Initialize largest and secondLargest with minimum possible values\n        int largest = Integer.MIN_VALUE;\n        int secondLargest = Integer.MIN_VALUE;\n\n        // Loop through each element in the array\n        for (int num : nums) {\n            // If current number is greater than largest\n            if (num > largest) {\n                // Update secondLargest before updating largest\n                secondLargest = largest;\n                largest = num;\n            }\n            // Else if current number is between largest and secondLargest\n            else if (num > secondLargest && num < largest) {\n                secondLargest = num;\n            }\n        }\n\n        // Return the second largest element\n        return secondLargest;\n    }\n\n    // Main method to test the logic\n    public static void main(String[] args) {\n        // Sample array input\n        int[] arr = {10, 20, 4, 45, 99};\n\n        // Print the second largest element\n        System.out.println(\"Second Largest: \" + findSecondLargest(arr));\n    }\n}\n",
    "input": "[10, 20, 4, 45, 99]",
    "output": "45",
    "explanation": "We maintain two variables: largest and secondLargest. Each time we find a new largest, we shift the old largest to secondLargest. If a number is smaller than largest but greater than secondLargest, we update secondLargest. This way, we only need one pass through the array."
  },
  {
    "question": "Check if the array is sorted.",
    "answer": "public class CheckSortedArray {\n\n    // Method to check if an array is sorted in ascending order\n    public static boolean isSorted(int[] nums) {\n        // Loop through the array until the second last element\n        for (int i = 0; i < nums.length - 1; i++) {\n            // If the current element is greater than the next, array is not sorted\n            if (nums[i] > nums[i + 1]) {\n                return false;\n            }\n        }\n        // If loop completes, array is sorted\n        return true;\n    }\n\n    // Main method to test the logic\n    public static void main(String[] args) {\n        // Sample array input\n        int[] arr = {1, 2, 3, 4, 5};\n\n        // Print result\n        System.out.println(\"Is Sorted: \" + isSorted(arr));\n    }\n}\n",
    "input": "[1, 2, 3, 4, 5]",
    "output": "true",
    "explanation": "We compare each element with the next one. If any element is greater than the next, the array is not sorted. If no such case is found, the array is sorted."
  },
  {
    "question": "Remove duplicates from a sorted array.",
    "answer": "public class RemoveDuplicatesSortedArray {\n\n    // Method to remove duplicates from a sorted array\n    public static int removeDuplicates(int[] nums) {\n        // If array is empty, return 0\n        if (nums.length == 0) {\n            return 0;\n        }\n\n        // Index to place the next unique element\n        int uniqueIndex = 1;\n\n        // Loop through array starting from index 1\n        for (int i = 1; i < nums.length; i++) {\n            // If current element is not equal to previous element\n            if (nums[i] != nums[i - 1]) {\n                // Place current element at uniqueIndex and increment uniqueIndex\n                nums[uniqueIndex] = nums[i];\n                uniqueIndex++;\n            }\n        }\n\n        // Return count of unique elements\n        return uniqueIndex;\n    }\n\n    // Main method to test the logic\n    public static void main(String[] args) {\n        // Sample sorted array with duplicates\n        int[] arr = {1, 1, 2, 2, 3, 4, 4, 5};\n\n        // Get new length after removing duplicates\n        int newLength = removeDuplicates(arr);\n\n        // Print unique elements\n        System.out.print(\"Array after removing duplicates: \");\n        for (int i = 0; i < newLength; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n",
    "input": "[1, 1, 2, 2, 3, 4, 4, 5]",
    "output": "[1, 2, 3, 4, 5]",
    "explanation": "Since the array is sorted, duplicates appear next to each other. We maintain a uniqueIndex to track where the next unique element should go. If a new unique element is found, we place it at uniqueIndex and increase uniqueIndex. Finally, elements up to uniqueIndex are the unique ones."
  },
   {
    "question": "Left rotate an array by D places.",
    "answer": "public class LeftRotateArray {\n\n    // Method to left rotate an array by d places\n    public static void leftRotate(int[] nums, int d) {\n        // Get array length\n        int n = nums.length;\n\n        // Handle cases where d is greater than n\n        d = d % n;\n\n        // Reverse the first d elements\n        reverse(nums, 0, d - 1);\n\n        // Reverse the remaining n-d elements\n        reverse(nums, d, n - 1);\n\n        // Reverse the whole array\n        reverse(nums, 0, n - 1);\n    }\n\n    // Helper method to reverse elements between two indices\n    public static void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            // Swap start and end elements\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample array\n        int[] arr = {1, 2, 3, 4, 5, 6, 7};\n        int d = 2; // number of rotations\n\n        // Perform left rotation\n        leftRotate(arr, d);\n\n        // Print rotated array\n        System.out.print(\"Array after left rotation: \");\n        for (int num : arr) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n",
    "input": "[1, 2, 3, 4, 5, 6, 7], d = 2",
    "output": "[3, 4, 5, 6, 7, 1, 2]",
    "explanation": "We use the reversal algorithm. First, reverse the first d elements, then reverse the rest of the array, and finally reverse the entire array. This effectively rotates the array left by d places."
  },
  {
    "question": "Move all zeros to the end of an array.",
    "answer": "public class MoveZerosToEnd {\n\n    // Method to move all zeros to the end\n    public static void moveZeros(int[] nums) {\n        // Index to place next non-zero element\n        int index = 0;\n\n        // Loop through array\n        for (int i = 0; i < nums.length; i++) {\n            // If current element is non-zero\n            if (nums[i] != 0) {\n                // Swap with element at index\n                int temp = nums[i];\n                nums[i] = nums[index];\n                nums[index] = temp;\n\n                // Move index forward\n                index++;\n            }\n        }\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample array\n        int[] arr = {0, 1, 0, 3, 12};\n\n        // Move zeros to end\n        moveZeros(arr);\n\n        // Print updated array\n        System.out.print(\"Array after moving zeros: \");\n        for (int num : arr) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n",
    "input": "[0, 1, 0, 3, 12]",
    "output": "[1, 3, 12, 0, 0]",
    "explanation": "We use the two-pointer technique. One pointer (index) tracks where the next non-zero element should go. Each time we see a non-zero, we swap it with the element at index. This keeps all non-zeros at the front, pushing zeros to the end."
  },
  {
    "question": "Find the missing number in an array.",
    "answer": "public class MissingNumberArray {\n\n    // Method to find the missing number\n    public static int findMissingNumber(int[] nums, int n) {\n        // Calculate expected sum of first n natural numbers\n        int expectedSum = n * (n + 1) / 2;\n\n        // Calculate actual sum of array elements\n        int actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n\n        // The difference is the missing number\n        return expectedSum - actualSum;\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Array with one missing number\n        int[] arr = {1, 2, 4, 5, 6};\n\n        // Range is from 1 to 6\n        int n = 6;\n\n        // Print missing number\n        System.out.println(\"Missing Number: \" + findMissingNumber(arr, n));\n    }\n}\n",
    "input": "[1, 2, 4, 5, 6], n = 6",
    "output": "3",
    "explanation": "We know the sum of first n natural numbers is n(n+1)/2. By subtracting the sum of given array elements from this expected sum, we find the missing number."
  },
  {
    "question": "Find the maximum number of consecutive 1s in a binary array.",
    "answer": "public class MaxConsecutiveOnes {\n\n    // Method to find maximum consecutive ones\n    public static int findMaxConsecutiveOnes(int[] nums) {\n        // Variable to track current streak of ones\n        int currentStreak = 0;\n        // Variable to track maximum streak found\n        int maxStreak = 0;\n\n        // Loop through each element\n        for (int num : nums) {\n            // If element is 1, increase current streak\n            if (num == 1) {\n                currentStreak++;\n                // Update maxStreak if needed\n                if (currentStreak > maxStreak) {\n                    maxStreak = currentStreak;\n                }\n            }\n            // If element is 0, reset current streak\n            else {\n                currentStreak = 0;\n            }\n        }\n\n        // Return maximum streak of ones\n        return maxStreak;\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample input\n        int[] arr = {1, 1, 0, 1, 1, 1};\n\n        // Print result\n        System.out.println(\"Maximum Consecutive Ones: \" + findMaxConsecutiveOnes(arr));\n    }\n}\n",
    "input": "[1, 1, 0, 1, 1, 1]",
    "output": "3",
    "explanation": "We maintain a current streak counter that increments when we see a 1, and resets to 0 when we see a 0. After each step, we update the maximum streak seen so far."
  },
  {
    "question": "Find the number that appears once in an array where all others appear twice.",
    "answer": "public class FindUniqueNumber {\n\n    // Method to find the unique number\n    public static int findUnique(int[] nums) {\n        // Initialize result with 0\n        int result = 0;\n\n        // XOR all numbers\n        for (int num : nums) {\n            result = result ^ num;\n        }\n\n        // Return the unique number\n        return result;\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample input\n        int[] arr = {2, 3, 5, 4, 5, 3, 2};\n\n        // Print unique number\n        System.out.println(\"Unique Number: \" + findUnique(arr));\n    }\n}\n",
    "input": "[2, 3, 5, 4, 5, 3, 2]",
    "output": "4",
    "explanation": "We use the XOR property: x ^ x = 0 and x ^ 0 = x. When all elements appear twice except one, XORing all elements cancels out pairs and leaves the unique number."
  },
  {
    "question": "Find the length of the longest subarray with a given sum K (positives only).",
    "answer": "public class LongestSubarraySumK {\n\n    // Method to find length of longest subarray with sum K\n    public static int longestSubarrayWithSumK(int[] nums, int k) {\n        int left = 0; // left pointer\n        int sum = 0;  // current window sum\n        int maxLength = 0; // maximum length found\n\n        // Loop through array with right pointer\n        for (int right = 0; right < nums.length; right++) {\n            // Add current element to sum\n            sum += nums[right];\n\n            // Shrink window from left if sum > k\n            while (sum > k && left <= right) {\n                sum -= nums[left];\n                left++;\n            }\n\n            // If sum equals k, update maxLength\n            if (sum == k) {\n                int currentLength = right - left + 1;\n                if (currentLength > maxLength) {\n                    maxLength = currentLength;\n                }\n            }\n        }\n\n        // Return longest length\n        return maxLength;\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample input\n        int[] arr = {1, 2, 1, 1, 1, 3, 2, 1};\n        int k = 5;\n\n        // Print result\n        System.out.println(\"Longest Subarray Length with Sum K: \" + longestSubarrayWithSumK(arr, k));\n    }\n}\n",
    "input": "[1, 2, 1, 1, 1, 3, 2, 1], k = 5",
    "output": "4",
    "explanation": "We use the sliding window technique since the array has only positive numbers. Expand the window by moving right, and shrink from the left if the sum exceeds K. Whenever sum equals K, update the maximum length."
  },
   {
    "question": "Solve the 2Sum problem: find indices of two numbers that add up to a target.",
    "answer": "import java.util.HashMap;\n\npublic class TwoSumProblem {\n\n    // Method to find indices of two numbers that add up to target\n    public static int[] twoSum(int[] nums, int target) {\n        // Create a hashmap to store number and its index\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        // Traverse the array\n        for (int i = 0; i < nums.length; i++) {\n            // Calculate the complement\n            int complement = target - nums[i];\n\n            // If complement exists in the map, return indices\n            if (map.containsKey(complement)) {\n                return new int[]{map.get(complement), i};\n            }\n\n            // Otherwise, put the current number with its index into the map\n            map.put(nums[i], i);\n        }\n\n        // If no solution is found, return an empty array\n        return new int[]{};\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample input\n        int[] arr = {2, 7, 11, 15};\n        int target = 9;\n\n        // Call twoSum method\n        int[] result = twoSum(arr, target);\n\n        // Print result\n        if (result.length == 2) {\n            System.out.println(\"Indices: [\" + result[0] + \", \" + result[1] + \"]\");\n        } else {\n            System.out.println(\"No solution found\");\n        }\n    }\n}\n",
    "input": "[2, 7, 11, 15], target = 9",
    "output": "[0, 1]",
    "explanation": "We use a HashMap to store numbers and their indices. For each element, we check if target - element is already in the map. If yes, we found the pair. This works in O(n) time."
  },
  {
    "question": "Sort an array of 0's, 1's, and 2's (Dutch National Flag problem).",
    "answer": "public class SortColors {\n\n    // Method to sort array of 0s, 1s, and 2s\n    public static void sortColors(int[] nums) {\n        // Initialize three pointers: low, mid, high\n        int low = 0;\n        int mid = 0;\n        int high = nums.length - 1;\n\n        // Traverse the array\n        while (mid <= high) {\n            // If element is 0, swap with low and move both pointers\n            if (nums[mid] == 0) {\n                int temp = nums[low];\n                nums[low] = nums[mid];\n                nums[mid] = temp;\n                low++;\n                mid++;\n            }\n            // If element is 1, just move mid\n            else if (nums[mid] == 1) {\n                mid++;\n            }\n            // If element is 2, swap with high and move high backward\n            else {\n                int temp = nums[mid];\n                nums[mid] = nums[high];\n                nums[high] = temp;\n                high--;\n            }\n        }\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample input\n        int[] arr = {2, 0, 2, 1, 1, 0};\n\n        // Sort the array\n        sortColors(arr);\n\n        // Print result\n        System.out.print(\"Sorted Array: \");\n        for (int num : arr) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n",
    "input": "[2, 0, 2, 1, 1, 0]",
    "output": "[0, 0, 1, 1, 2, 2]",
    "explanation": "We use three pointers: low, mid, and high. If nums[mid] is 0, swap with low. If nums[mid] is 1, just move mid. If nums[mid] is 2, swap with high. This sorts the array in a single pass."
  },
  {
    "question": "Find the majority element (appears more than n/2 times).",
    "answer": "public class MajorityElement {\n\n    // Method to find the majority element using Boyer-Moore Voting Algorithm\n    public static int findMajorityElement(int[] nums) {\n        // Initialize candidate and count\n        int candidate = 0;\n        int count = 0;\n\n        // First pass: find potential candidate\n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            if (num == candidate) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n\n        // Return the candidate (guaranteed to be majority in this problem)\n        return candidate;\n    }\n\n    // Main method to test logic\n    public static void main(String[] args) {\n        // Sample input\n        int[] arr = {3, 3, 4, 2, 3, 3, 5, 3};\n\n        // Print majority element\n        System.out.println(\"Majority Element: \" + findMajorityElement(arr));\n    }\n}\n",
    "input": "[3, 3, 4, 2, 3, 3, 5, 3]",
    "output": "3",
    "explanation": "We use Boyer-Moore Voting Algorithm. We maintain a candidate and a count. When count becomes 0, we set a new candidate. For each occurrence of the candidate, we increase count, otherwise decrease it. The majority element remains as the final candidate."
  },{
    "question": "Kadane's Algorithm (Maximum Subarray Sum)",
    "answer": "public class KadanesAlgorithm {\n\n    // Method to find the maximum subarray sum\n    public static int maxSubArraySum(int[] nums) {\n        // Initialize current sum and maximum sum\n        int currentSum = nums[0];\n        int maxSum = nums[0];\n\n        // Traverse the array from the second element\n        for (int i = 1; i < nums.length; i++) {\n            // Update current sum (either start new subarray or continue existing)\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\n\n            // Update max sum if current sum is greater\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n            }\n        }\n\n        // Return the maximum subarray sum\n        return maxSum;\n    }\n\n    // Main method to test\n    public static void main(String[] args) {\n        int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n        System.out.println(\"Maximum Subarray Sum: \" + maxSubArraySum(arr));\n    }\n}\n",
    "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
    "output": "6",
    "explanation": "We maintain a current sum and keep extending the subarray if it increases the sum. Otherwise, we restart from the current element. The maximum of all current sums gives the answer. The subarray [4, -1, 2, 1] gives the sum 6."
  },
  {
    "question": "Print Subarray with Maximum Subarray Sum",
    "answer": "public class PrintMaxSubarraySum {\n\n    // Method to print subarray with maximum sum\n    public static void printMaxSubArray(int[] nums) {\n        int currentSum = nums[0];\n        int maxSum = nums[0];\n\n        int start = 0;\n        int tempStart = 0;\n        int end = 0;\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > currentSum + nums[i]) {\n                currentSum = nums[i];\n                tempStart = i; // new subarray start\n            } else {\n                currentSum = currentSum + nums[i];\n            }\n\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n                start = tempStart;\n                end = i;\n            }\n        }\n\n        // Print the maximum sum\n        System.out.println(\"Maximum Subarray Sum: \" + maxSum);\n\n        // Print the actual subarray\n        System.out.print(\"Subarray: [\");\n        for (int i = start; i <= end; i++) {\n            System.out.print(nums[i]);\n            if (i < end) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println(\"]\");\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n        printMaxSubArray(arr);\n    }\n}\n",
    "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
    "output": "Maximum Subarray Sum: 6, Subarray: [4, -1, 2, 1]",
    "explanation": "We keep track of temporary start index whenever we start a new subarray. When we find a new maximum sum, we update the start and end indices. Finally, we print both the sum and the subarray elements."
  },
  {
    "question": "Stock Buy and Sell (Single Transaction)",
    "answer": "public class StockBuySell {\n\n    // Method to find maximum profit from one transaction\n    public static int maxProfit(int[] prices) {\n        int minPrice = prices[0];\n        int maxProfit = 0;\n\n        // Traverse prices\n        for (int i = 1; i < prices.length; i++) {\n            // Update minPrice if current price is smaller\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            }\n\n            // Calculate profit if selling today\n            int profit = prices[i] - minPrice;\n\n            // Update maxProfit if current profit is greater\n            if (profit > maxProfit) {\n                maxProfit = profit;\n            }\n        }\n\n        return maxProfit;\n    }\n\n    public static void main(String[] args) {\n        int[] prices = {7, 1, 5, 3, 6, 4};\n        System.out.println(\"Maximum Profit: \" + maxProfit(prices));\n    }\n}\n",
    "input": "[7, 1, 5, 3, 6, 4]",
    "output": "5",
    "explanation": "We maintain the minimum price seen so far and calculate profit by selling at the current price. The maximum of all such profits is the answer. Buy at 1, sell at 6 → profit = 5."
  },
   {
    "question": "Rearrange Array in Alternating Positive and Negative Numbers",
    "answer": "public class RearrangeAlternating {\n\n    // Method to rearrange array in alternating positive and negative numbers\n    public static void rearrange(int[] nums) {\n        int n = nums.length;\n        int[] temp = new int[n];\n        int posIndex = 0;\n        int negIndex = 0;\n\n        // Count how many positives and negatives\n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= 0) {\n                temp[posIndex++] = nums[i];\n            } else {\n                temp[n - 1 - negIndex++] = nums[i];\n            }\n        }\n\n        // Now place them alternately\n        int i = 0;\n        int j = n - negIndex;\n        int k = 0;\n\n        while (i < posIndex && j < n) {\n            nums[k++] = temp[i++];\n            nums[k++] = temp[j++];\n        }\n\n        // If any positives left\n        while (i < posIndex) {\n            nums[k++] = temp[i++];\n        }\n\n        // If any negatives left\n        while (j < n) {\n            nums[k++] = temp[j++];\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, -4, -1, 4};\n        rearrange(arr);\n        System.out.print(\"Rearranged Array: [\");\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]);\n            if (i < arr.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println(\"]\");\n    }\n}\n",
    "input": "[1, 2, 3, -4, -1, 4]",
    "output": "[1, -4, 2, -1, 3, 4]",
    "explanation": "We first separate positive and negative numbers, then merge them alternately into the original array. If one type runs out, we append the remaining elements."
  },
  {
    "question": "Next Permutation",
    "answer": "public class NextPermutation {\n\n    // Method to rearrange numbers into the next lexicographically greater permutation\n    public static void nextPermutation(int[] nums) {\n        int n = nums.length;\n        int i = n - 2;\n\n        // Find first decreasing element from right\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n\n        if (i >= 0) {\n            // Find next greater element from the right\n            int j = n - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n\n            // Swap\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n\n        // Reverse the suffix\n        int start = i + 1;\n        int end = n - 1;\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3};\n        nextPermutation(arr);\n        System.out.print(\"Next Permutation: [\");\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]);\n            if (i < arr.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println(\"]\");\n    }\n}\n",
    "input": "[1, 2, 3]",
    "output": "[1, 3, 2]",
    "explanation": "We find the first pair where nums[i] < nums[i+1] from the right. Then, swap it with the next greater element from the right side and finally reverse the suffix to get the smallest possible arrangement after the swap."
  },
  {
    "question": "Leaders in an Array",
    "answer": "public class LeadersInArray {\n\n    // Method to print leaders in the array\n    public static void printLeaders(int[] nums) {\n        int n = nums.length;\n        int maxFromRight = nums[n - 1];\n\n        System.out.print(\"Leaders: [\" + maxFromRight);\n\n        for (int i = n - 2; i >= 0; i--) {\n            if (nums[i] > maxFromRight) {\n                maxFromRight = nums[i];\n                System.out.print(\", \" + maxFromRight);\n            }\n        }\n\n        System.out.println(\"]\");\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {16, 17, 4, 3, 5, 2};\n        printLeaders(arr);\n    }\n}\n",
    "input": "[16, 17, 4, 3, 5, 2]",
    "output": "[2, 5, 17]",
    "explanation": "We traverse the array from right to left, keeping track of the maximum. An element is a leader if it is greater than all elements to its right. Leaders are collected in reverse order."
  },
   {
    "question": "Longest Consecutive Sequence in an Array",
    "answer": "import java.util.*;\n\npublic class LongestConsecutiveSequence {\n\n    // Method to find the longest consecutive sequence length\n    public static int longestConsecutive(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n\n        // Add all elements to the set\n        for (int num : nums) {\n            set.add(num);\n        }\n\n        int longestStreak = 0;\n\n        // Iterate through each number\n        for (int num : set) {\n            // Check if it's the start of a sequence\n            if (!set.contains(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n\n                // Count consecutive numbers\n                while (set.contains(currentNum + 1)) {\n                    currentNum++;\n                    currentStreak++;\n                }\n\n                // Update the longest streak\n                if (currentStreak > longestStreak) {\n                    longestStreak = currentStreak;\n                }\n            }\n        }\n\n        return longestStreak;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {100, 4, 200, 1, 3, 2};\n        System.out.println(\"Longest Consecutive Sequence Length: \" + longestConsecutive(arr));\n    }\n}\n",
    "input": "[100, 4, 200, 1, 3, 2]",
    "output": "4",
    "explanation": "We use a HashSet to quickly check existence. A sequence starts only if (num-1) is not in the set. Then, we expand forward to count the sequence. The longest streak found is the answer. Sequence [1, 2, 3, 4] gives length 4."
  },
  {
    "question": "3-Sum Problem",
    "answer": "import java.util.*;\n\npublic class ThreeSumProblem {\n\n    // Method to find all unique triplets that sum to zero\n    public static List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums); // Sort the array\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue; // Skip duplicates\n            }\n\n            int left = i + 1;\n            int right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                    left++;\n                    right--;\n\n                    // Skip duplicates for left\n                    while (left < right && nums[left] == nums[left - 1]) {\n                        left++;\n                    }\n\n                    // Skip duplicates for right\n                    while (left < right && nums[right] == nums[right + 1]) {\n                        right--;\n                    }\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-1, 0, 1, 2, -1, -4};\n        List<List<Integer>> triplets = threeSum(arr);\n        System.out.println(\"Triplets that sum to 0: \" + triplets);\n    }\n}\n",
    "input": "[-1, 0, 1, 2, -1, -4]",
    "output": "[[-1, -1, 2], [-1, 0, 1]]",
    "explanation": "We sort the array and fix one element. Then, we use a two-pointer approach to find pairs that sum with it to zero. Duplicates are skipped to ensure unique triplets."
  },
  {
    "question": "Merge Overlapping Subintervals",
    "answer": "import java.util.*;\n\npublic class MergeIntervals {\n\n    // Method to merge overlapping intervals\n    public static int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        List<int[]> merged = new ArrayList<>();\n\n        int[] current = intervals[0];\n        merged.add(current);\n\n        for (int[] interval : intervals) {\n            // If intervals overlap, merge them\n            if (interval[0] <= current[1]) {\n                current[1] = Math.max(current[1], interval[1]);\n            } else {\n                current = interval;\n                merged.add(current);\n            }\n        }\n\n        return merged.toArray(new int[merged.size()][]);\n    }\n\n    public static void main(String[] args) {\n        int[][] intervals = {{1,3}, {2,6}, {8,10}, {15,18}};\n        int[][] result = merge(intervals);\n        System.out.print(\"Merged Intervals: [\");\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(\"[\" + result[i][0] + \", \" + result[i][1] + \"]\");\n            if (i < result.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println(\"]\");\n    }\n}\n",
    "input": "[[1,3],[2,6],[8,10],[15,18]]",
    "output": "[[1,6],[8,10],[15,18]]",
    "explanation": "We first sort intervals by start time. Then, we traverse and merge overlapping intervals by adjusting the end time. If they do not overlap, we add a new interval to the result."
  },
   {
    "question": "Merge Two Sorted Arrays without Extra Space",
    "answer": "import java.util.*;\n\npublic class MergeSortedArrays {\n\n    // Method to merge two sorted arrays without using extra space\n    public static void merge(int[] arr1, int[] arr2, int n, int m) {\n        int i = n - 1;\n        int j = 0;\n\n        // Swap elements until arr1's largest is smaller than arr2's smallest\n        while (i >= 0 && j < m) {\n            if (arr1[i] > arr2[j]) {\n                int temp = arr1[i];\n                arr1[i] = arr2[j];\n                arr2[j] = temp;\n            }\n            i--;\n            j++;\n        }\n\n        // Sort both arrays again\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {1, 3, 5, 7};\n        int[] arr2 = {0, 2, 6, 8, 9};\n\n        merge(arr1, arr2, arr1.length, arr2.length);\n\n        System.out.print(\"Array 1: [\");\n        for (int i = 0; i < arr1.length; i++) {\n            System.out.print(arr1[i]);\n            if (i < arr1.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println(\"]\");\n\n        System.out.print(\"Array 2: [\");\n        for (int i = 0; i < arr2.length; i++) {\n            System.out.print(arr2[i]);\n            if (i < arr2.length - 1) {\n                System.out.print(\", \");\n            }\n        }\n        System.out.println(\"]\");\n    }\n}\n",
    "input": "arr1 = [1, 3, 5, 7], arr2 = [0, 2, 6, 8, 9]",
    "output": "arr1 = [0, 1, 2, 3], arr2 = [5, 6, 7, 8, 9]",
    "explanation": "We compare the largest elements of arr1 with the smallest of arr2 and swap if needed. Afterward, we sort both arrays individually. This ensures both arrays remain sorted without using extra space."
  },
  {
    "question": "Largest Subarray with 0 Sum",
    "answer": "import java.util.*;\n\npublic class LargestSubarrayZeroSum {\n\n    // Method to find length of largest subarray with sum 0\n    public static int maxLen(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int sum = 0;\n        int maxLength = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n\n            if (sum == 0) {\n                maxLength = i + 1;\n            }\n\n            if (map.containsKey(sum)) {\n                int prevIndex = map.get(sum);\n                int length = i - prevIndex;\n                if (length > maxLength) {\n                    maxLength = length;\n                }\n            } else {\n                map.put(sum, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {15, -2, 2, -8, 1, 7, 10, 23};\n        System.out.println(\"Largest Subarray with 0 Sum Length: \" + maxLen(arr));\n    }\n}\n",
    "input": "[15, -2, 2, -8, 1, 7, 10, 23]",
    "output": "5",
    "explanation": "We use a prefix sum and HashMap to store the first occurrence of each sum. If the same sum occurs again, the subarray between them has sum 0. We track the maximum length among such subarrays."
  },
  {
    "question": "Maximum Product Subarray",
    "answer": "public class MaxProductSubarray {\n\n    // Method to find maximum product of a subarray\n    public static int maxProduct(int[] nums) {\n        int maxProduct = nums[0];\n        int minProduct = nums[0];\n        int result = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            int current = nums[i];\n\n            // Swap if current is negative\n            if (current < 0) {\n                int temp = maxProduct;\n                maxProduct = minProduct;\n                minProduct = temp;\n            }\n\n            // Update maxProduct and minProduct\n            maxProduct = Math.max(current, maxProduct * current);\n            minProduct = Math.min(current, minProduct * current);\n\n            // Update result\n            if (maxProduct > result) {\n                result = maxProduct;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 3, -2, 4};\n        System.out.println(\"Maximum Product Subarray: \" + maxProduct(arr));\n    }\n}\n",
    "input": "[2, 3, -2, 4]",
    "output": "6",
    "explanation": "We maintain both max and min products at each step because a negative number can flip signs. The maximum product among all subarrays is updated iteratively. For input [2, 3, -2, 4], the maximum product is 6 from subarray [2, 3]."
  },
  {
  "question": "Majority Element (n/3 times)",
  "answer": "import java.util.*;\n\npublic class MajorityElementNBy3 {\n\n    // Method to find elements appearing more than n/3 times\n    public static List<Integer> majorityElement(int[] nums) {\n        int n = nums.length;\n        int count1 = 0, count2 = 0;\n        Integer candidate1 = null, candidate2 = null;\n\n        // Step 1: Find two possible candidates\n        for (int num : nums) {\n            if (candidate1 != null && num == candidate1) {\n                count1++;\n            } else if (candidate2 != null && num == candidate2) {\n                count2++;\n            } else if (count1 == 0) {\n                candidate1 = num;\n                count1 = 1;\n            } else if (count2 == 0) {\n                candidate2 = num;\n                count2 = 1;\n            } else {\n                count1--;\n                count2--;\n            }\n        }\n\n        // Step 2: Verify actual counts\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) {\n            if (candidate1 != null && num == candidate1) count1++;\n            else if (candidate2 != null && num == candidate2) count2++;\n        }\n\n        // Step 3: Collect results\n        List<Integer> result = new ArrayList<>();\n        if (count1 > n / 3) result.add(candidate1);\n        if (count2 > n / 3) result.add(candidate2);\n\n        return result;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 2, 3, 2, 1, 1, 3};\n        System.out.println(\"Majority Elements (> n/3 times): \" + majorityElement(nums));\n    }\n}\n",
  "input": "[1, 2, 2, 3, 2, 1, 1, 3]",
  "output": "[1, 2]",
  "explanation": "We maintain two potential candidates since more than n/3 elements can be at most 2. Using the Boyer-Moore voting algorithm, we first identify possible candidates, then verify their actual counts. In this case, 1 and 2 both appear more than ⌊8/3⌋ = 2 times, so they are the majority elements."
}

  ]