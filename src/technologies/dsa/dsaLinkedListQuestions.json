[
  {
    "question": "Introduction to LinkedList: Define the basic structure of a Linked List and represent a node. A Linked List is a linear data structure where each element (node) points to the next node, forming a chain. Unlike arrays, linked lists are dynamic in size and efficient for insertion and deletion.",
    "answer": "public class LinkedListBasics {\n\n    // Node structure representing each element in the Linked List\n    static class Node {\n        int data;           // Data stored in the node\n        Node next;          // Reference to the next node\n\n        // Constructor to create a new node\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    // Head of the Linked List\n    Node head;\n\n    // Method to print the Linked List\n    public void printList() {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" -> \");\n            temp = temp.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args) {\n        LinkedListBasics list = new LinkedListBasics();\n\n        // Creating nodes manually\n        list.head = new Node(10);\n        Node second = new Node(20);\n        Node third = new Node(30);\n\n        // Linking nodes\n        list.head.next = second;\n        second.next = third;\n\n        // Printing the list\n        list.printList();\n    }\n}\n",
    "input": "10 -> 20 -> 30",
    "output": "10 -> 20 -> 30 -> null",
    "explanation": "We created a simple linked list with 3 nodes. Each node stores data and a reference to the next node. The printList method traverses the list and prints elements until the end."
  },
  {
    "question": "Insert a node in LinkedList at different positions: Insert at the head (beginning), at the tail (end), and at a specific position. This helps build a dynamic list structure where elements can be added flexibly.",
    "answer": "public class LinkedListInsertion {\n\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Insert at the beginning\n    public void insertAtHead(int data) {\n        Node newNode = new Node(data);\n        newNode.next = head;\n        head = newNode;\n    }\n\n    // Insert at the end\n    public void insertAtTail(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) {\n            temp = temp.next;\n        }\n        temp.next = newNode;\n    }\n\n    // Insert at a given position (1-based index)\n    public void insertAtPosition(int data, int position) {\n        if (position == 1) {\n            insertAtHead(data);\n            return;\n        }\n        Node newNode = new Node(data);\n        Node temp = head;\n        for (int i = 1; i < position - 1 && temp != null; i++) {\n            temp = temp.next;\n        }\n        if (temp == null) return; // Position out of range\n        newNode.next = temp.next;\n        temp.next = newNode;\n    }\n\n    // Print Linked List\n    public void printList() {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" -> \");\n            temp = temp.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args) {\n        LinkedListInsertion list = new LinkedListInsertion();\n        list.insertAtHead(10);\n        list.insertAtTail(20);\n        list.insertAtTail(30);\n        list.insertAtPosition(15, 2);\n        list.printList();\n    }\n}\n",
    "input": "Insert 10 at head, Insert 20 at tail, Insert 30 at tail, Insert 15 at position 2",
    "output": "10 -> 15 -> 20 -> 30 -> null",
    "explanation": "We implemented methods to insert at the head, tail, and a given position. Traversal is used to find the correct position for insertion. Each insertion updates node links accordingly."
  },
  {
    "question": "Delete a node in LinkedList: Remove a node by its value (key). If the key is found, unlink that node from the list. This demonstrates how to adjust node references during deletion.",
    "answer": "public class LinkedListDeletion {\n\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Insert at end utility\n    public void insertAtTail(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) {\n            temp = temp.next;\n        }\n        temp.next = newNode;\n    }\n\n    // Delete by key\n    public void deleteNode(int key) {\n        if (head == null) return;\n\n        // If head node holds the key\n        if (head.data == key) {\n            head = head.next;\n            return;\n        }\n\n        Node temp = head;\n        while (temp.next != null && temp.next.data != key) {\n            temp = temp.next;\n        }\n\n        if (temp.next == null) return; // Key not found\n\n        temp.next = temp.next.next;\n    }\n\n    public void printList() {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" -> \");\n            temp = temp.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args) {\n        LinkedListDeletion list = new LinkedListDeletion();\n        list.insertAtTail(10);\n        list.insertAtTail(20);\n        list.insertAtTail(30);\n        list.insertAtTail(40);\n\n        list.deleteNode(20);\n        list.printList();\n    }\n}\n",
    "input": "10 -> 20 -> 30 -> 40, delete 20",
    "output": "10 -> 30 -> 40 -> null",
    "explanation": "We check if the head holds the key; if so, move the head to the next node. Otherwise, traverse until the node before the target and adjust the next pointer to skip the target node."
  },
  {
    "question": "Find the length of the LinkedList: Traverse through all nodes, counting each node until reaching the end (null). This shows how traversal works to compute size dynamically.",
    "answer": "public class LinkedListLength {\n\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Insert utility\n    public void insertAtTail(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) {\n            temp = temp.next;\n        }\n        temp.next = newNode;\n    }\n\n    // Method to count length\n    public int getLength() {\n        int count = 0;\n        Node temp = head;\n        while (temp != null) {\n            count++;\n            temp = temp.next;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        LinkedListLength list = new LinkedListLength();\n        list.insertAtTail(5);\n        list.insertAtTail(10);\n        list.insertAtTail(15);\n\n        System.out.println(\"Length of Linked List: \" + list.getLength());\n    }\n}\n",
    "input": "5 -> 10 -> 15",
    "output": "Length of Linked List: 3",
    "explanation": "We traverse each node, incrementing a counter until the end. This dynamic approach ensures the length is always accurate, unlike arrays where size is fixed."
  },
  {
    "question": "Search an element in LinkedList. Implement a function to check whether a given key exists in the LinkedList or not.",
    "answer": "class LinkedListSearch {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Method to insert at the end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Method to search key\n    public boolean search(int key) {\n        Node temp = head;\n        while (temp != null) {\n            if (temp.data == key) return true;\n            temp = temp.next;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        LinkedListSearch list = new LinkedListSearch();\n        list.insert(10);\n        list.insert(20);\n        list.insert(30);\n\n        System.out.println(list.search(20)); // true\n        System.out.println(list.search(50)); // false\n    }\n}",
    "input": "[10, 20, 30], key = 20",
    "output": "true",
    "explanation": "Traverse through the Linked List and compare each node’s data with the key. If found, return true; otherwise, false."
  },
  {
    "question": "Find the middle of the Linked List (LeetCode). Given the head of a LinkedList, return the middle node. If there are two middle nodes, return the second one.",
    "answer": "class MiddleLinkedList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Find middle using slow and fast pointers\n    public Node findMiddle() {\n        Node slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        MiddleLinkedList list = new MiddleLinkedList();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        list.insert(4);\n        list.insert(5);\n\n        System.out.println(list.findMiddle().data); // 3\n    }\n}",
    "input": "[1, 2, 3, 4, 5]",
    "output": "3",
    "explanation": "Use two pointers: move slow pointer by 1 step and fast pointer by 2 steps. When fast reaches the end, slow will be at the middle."
  },
  {
    "question": "Reverse a Linked List (Iterative). Given the head of a Linked List, reverse the list and return its new head.",
    "answer": "class ReverseLinkedList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Reverse iteratively\n    public Node reverse() {\n        Node prev = null, curr = head;\n        while (curr != null) {\n            Node nextNode = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n        head = prev;\n        return head;\n    }\n\n    public void printList(Node node) {\n        while (node != null) {\n            System.out.print(node.data + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        ReverseLinkedList list = new ReverseLinkedList();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        list.insert(4);\n\n        list.head = list.reverse();\n        list.printList(list.head); // 4 3 2 1\n    }\n}",
    "input": "[1, 2, 3, 4]",
    "output": "[4, 3, 2, 1]",
    "explanation": "Iteratively reverse by changing the next pointer of each node to point to its previous node."
  },
  {
    "question": "Check if a Linked List is Palindrome (LeetCode Snapdeal). Given the head of a Linked List, return true if it is a palindrome.",
    "answer": "class PalindromeLinkedList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Find middle, reverse second half, compare\n    public boolean isPalindrome() {\n        if (head == null || head.next == null) return true;\n\n        Node slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // Reverse second half\n        Node secondHalf = reverse(slow.next);\n        Node firstHalf = head;\n\n        while (secondHalf != null) {\n            if (firstHalf.data != secondHalf.data) return false;\n            firstHalf = firstHalf.next;\n            secondHalf = secondHalf.next;\n        }\n        return true;\n    }\n\n    // Reverse helper\n    private Node reverse(Node node) {\n        Node prev = null, curr = node;\n        while (curr != null) {\n            Node nextNode = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n        return prev;\n    }\n\n    public static void main(String[] args) {\n        PalindromeLinkedList list = new PalindromeLinkedList();\n        list.insert(1);\n        list.insert(2);\n        list.insert(2);\n        list.insert(1);\n\n        System.out.println(list.isPalindrome()); // true\n    }\n}",
    "input": "[1, 2, 2, 1]",
    "output": "true",
    "explanation": "Find the middle of the list, reverse the second half, then compare the first half and second half. If all match, it's a palindrome."
  },
  {
    "question": "Merge Two Sorted Lists (LeetCode). Given two sorted linked lists, merge them into a single sorted linked list and return its head.",
    "answer": "class MergeSortedLists {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) { head = newNode; return; }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Merge two sorted lists\n    public static Node merge(Node l1, Node l2) {\n        Node dummy = new Node(0);\n        Node tail = dummy;\n\n        while (l1 != null && l2 != null) {\n            if (l1.data <= l2.data) {\n                tail.next = l1;\n                l1 = l1.next;\n            } else {\n                tail.next = l2;\n                l2 = l2.next;\n            }\n            tail = tail.next;\n        }\n\n        if (l1 != null) tail.next = l1;\n        else tail.next = l2;\n\n        return dummy.next;\n    }\n\n    public static void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        MergeSortedLists l1 = new MergeSortedLists();\n        l1.insert(1); l1.insert(3); l1.insert(5);\n        MergeSortedLists l2 = new MergeSortedLists();\n        l2.insert(2); l2.insert(4); l2.insert(6);\n\n        Node merged = merge(l1.head, l2.head);\n        printList(merged); // 1 2 3 4 5 6\n    }\n}",
    "input": "List1 = [1, 3, 5], List2 = [2, 4, 6]",
    "output": "[1, 2, 3, 4, 5, 6]",
    "explanation": "We traverse both lists, picking the smaller node each time. Attach it to the merged list until one list is exhausted, then append the remaining nodes."
  },
  {
    "question": "Remove Duplicates from Sorted List (LeetCode). Given the head of a sorted linked list, delete all duplicates such that each element appears only once.",
    "answer": "class RemoveDuplicatesSortedList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) { head = newNode; return; }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Remove duplicates\n    public void removeDuplicates() {\n        Node curr = head;\n        while (curr != null && curr.next != null) {\n            if (curr.data == curr.next.data) {\n                curr.next = curr.next.next; // skip duplicate\n            } else {\n                curr = curr.next;\n            }\n        }\n    }\n\n    public void printList() {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" \");\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        RemoveDuplicatesSortedList list = new RemoveDuplicatesSortedList();\n        list.insert(1);\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        list.insert(3);\n\n        list.removeDuplicates();\n        list.printList(); // 1 2 3\n    }\n}",
    "input": "[1, 1, 2, 3, 3]",
    "output": "[1, 2, 3]",
    "explanation": "Since the list is sorted, duplicates will always be adjacent. We traverse and skip duplicate nodes by adjusting pointers."
  },
  {
    "question": "Detect a cycle in Linked List (Floyd’s Algorithm – LeetCode Samsung). Given the head of a Linked List, determine if the linked list contains a cycle.",
    "answer": "class DetectCycleLinkedList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) { head = newNode; return; }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Detect cycle using Floyd's algorithm\n    public boolean hasCycle() {\n        Node slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        DetectCycleLinkedList list = new DetectCycleLinkedList();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n\n        // Creating a cycle: last node points back to head\n        list.head.next.next.next = list.head;\n\n        System.out.println(list.hasCycle()); // true\n    }\n}",
    "input": "[1, 2, 3] with a cycle (3 -> 1)",
    "output": "true",
    "explanation": "Use Floyd’s cycle-finding algorithm: move slow pointer by 1 step and fast pointer by 2 steps. If they ever meet, a cycle exists."
  },
  {
    "question": "Linked List Cycle II – Find starting point (LeetCode). Given the head of a Linked List, return the node where the cycle begins. If there is no cycle, return null.",
    "answer": "class LinkedListCycleII {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    Node head;\n\n    // Insert at end\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) { head = newNode; return; }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Detect cycle and find starting point\n    public Node detectCycleStart() {\n        Node slow = head, fast = head;\n        boolean cycle = false;\n\n        // Step 1: Detect cycle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) { cycle = true; break; }\n        }\n\n        // Step 2: Find start of cycle\n        if (cycle) {\n            slow = head;\n            while (slow != fast) {\n                slow = slow.next;\n                fast = fast.next;\n            }\n            return slow;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        LinkedListCycleII list = new LinkedListCycleII();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        list.insert(4);\n\n        // Create cycle: 4 -> 2\n        list.head.next.next.next.next = list.head.next;\n\n        Node start = list.detectCycleStart();\n        if (start != null) System.out.println(start.data); // 2\n        else System.out.println(\"No cycle\");\n    }\n}",
    "input": "[1, 2, 3, 4] with a cycle (4 -> 2)",
    "output": "2",
    "explanation": "After detecting cycle with Floyd’s algorithm, move one pointer to head and keep the other at meeting point. Move both one step at a time; the node where they meet is the cycle start."
  },
   {
    "question": "Remove Nth Node from End of LinkedList (LeetCode HSBC). Given the head of a linked list, remove the nth node from the end and return its head.",
    "answer": "class RemoveNthFromEnd {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    Node head;\n\n    public void insert(int data) {\n        Node newNode = new Node(data);\n        if (head == null) { head = newNode; return; }\n        Node temp = head;\n        while (temp.next != null) temp = temp.next;\n        temp.next = newNode;\n    }\n\n    // Remove Nth node from end using two-pointer technique\n    public Node removeNthFromEnd(Node head, int n) {\n        Node dummy = new Node(0);\n        dummy.next = head;\n        Node first = dummy, second = dummy;\n\n        // Move first pointer n+1 steps ahead\n        for (int i = 0; i <= n; i++) first = first.next;\n\n        // Move both until first reaches null\n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n\n        // Remove target node\n        second.next = second.next.next;\n        return dummy.next;\n    }\n\n    public void printList(Node node) {\n        while (node != null) {\n            System.out.print(node.data + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        RemoveNthFromEnd list = new RemoveNthFromEnd();\n        list.insert(1); list.insert(2); list.insert(3); list.insert(4); list.insert(5);\n\n        Node updated = list.removeNthFromEnd(list.head, 2);\n        list.printList(updated); // 1 2 3 5\n    }\n}",
    "input": "[1, 2, 3, 4, 5], n = 2",
    "output": "[1, 2, 3, 5]",
    "explanation": "We use two pointers. First moves n+1 steps ahead, then move both until the first reaches the end. The second pointer will be just before the target node to remove."
  },
  {
    "question": "Intersection of Two Linked Lists (LeetCode). Given the heads of two linked lists, return the node at which the two lists intersect. If they do not intersect, return null.",
    "answer": "class IntersectionTwoLists {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    // Find intersection using two-pointer technique\n    public Node getIntersectionNode(Node headA, Node headB) {\n        if (headA == null || headB == null) return null;\n        Node a = headA, b = headB;\n\n        // Traverse both, reset to other list when reaching null\n        while (a != b) {\n            a = (a == null) ? headB : a.next;\n            b = (b == null) ? headA : b.next;\n        }\n        return a; // either intersection or null\n    }\n\n    public static void main(String[] args) {\n        IntersectionTwoLists list = new IntersectionTwoLists();\n\n        Node common = new Node(8);\n        common.next = new Node(10);\n\n        Node headA = new Node(3);\n        headA.next = new Node(7);\n        headA.next.next = common;\n\n        Node headB = new Node(99);\n        headB.next = common;\n\n        Node intersection = list.getIntersectionNode(headA, headB);\n        System.out.println(intersection != null ? intersection.data : \"No intersection\"); // 8\n    }\n}",
    "input": "ListA = [3, 7, 8, 10], ListB = [99, 8, 10]",
    "output": "8",
    "explanation": "We use two pointers. Each pointer traverses both lists once by switching heads when reaching the end. If they intersect, they meet at the intersection node; otherwise both become null."
  },
  {
    "question": "Odd Even Linked List (LeetCode). Given the head of a linked list, group all the nodes with odd indices together followed by the nodes with even indices.",
    "answer": "class OddEvenLinkedList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    public Node oddEvenList(Node head) {\n        if (head == null) return null;\n        Node odd = head, even = head.next, evenHead = even;\n\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        odd.next = evenHead; // append even list after odd\n        return head;\n    }\n\n    public void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        OddEvenLinkedList list = new OddEvenLinkedList();\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        Node result = list.oddEvenList(head);\n        list.printList(result); // 1 3 5 2 4\n    }\n}",
    "input": "[1, 2, 3, 4, 5]",
    "output": "[1, 3, 5, 2, 4]",
    "explanation": "We maintain two lists: odd nodes and even nodes. Rearrange pointers so all odd nodes come first followed by even nodes, keeping relative order."
  },
  {
    "question": "Reorder List (LeetCode). Given the head of a linked list, reorder it as L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...",
    "answer": "class ReorderList {\n    static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; this.next = null; }\n    }\n\n    public void reorderList(Node head) {\n        if (head == null || head.next == null) return;\n\n        // Step 1: Find middle\n        Node slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // Step 2: Reverse second half\n        Node prev = null, curr = slow.next;\n        while (curr != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        slow.next = null; // cut first half\n\n        // Step 3: Merge two halves\n        Node first = head, second = prev;\n        while (second != null) {\n            Node temp1 = first.next;\n            Node temp2 = second.next;\n            first.next = second;\n            second.next = temp1;\n            first = temp1;\n            second = temp2;\n        }\n    }\n\n    public void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        ReorderList list = new ReorderList();\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        list.reorderList(head);\n        list.printList(head); // 1 5 2 4 3\n    }\n}",
    "input": "[1, 2, 3, 4, 5]",
    "output": "[1, 5, 2, 4, 3]",
    "explanation": "We first find the middle node, reverse the second half, and then merge nodes from first and reversed halves alternatively."
  },
  {
    "question": "Add Two Numbers (LeetCode – must do, asked in FAANG). You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each node contains a single digit. Add the two numbers and return the sum as a linked list.",
    "answer": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class AddTwoNumbers {\n\n    // Function to add two numbers represented by linked lists\n    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        int carry = 0;\n\n        // Traverse both lists\n        while (l1 != null || l2 != null) {\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        if (carry > 0) {\n            curr.next = new ListNode(carry);\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        // Example: 342 + 465 = 807\n        ListNode l1 = new ListNode(2);\n        l1.next = new ListNode(4);\n        l1.next.next = new ListNode(3);\n\n        ListNode l2 = new ListNode(5);\n        l2.next = new ListNode(6);\n        l2.next.next = new ListNode(4);\n\n        ListNode result = addTwoNumbers(l1, l2);\n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n",
    "input": "l1 = [2,4,3], l2 = [5,6,4]",
    "output": "[7,0,8]",
    "explanation": "We traverse both lists digit by digit, summing and carrying over when necessary. Example: 342 + 465 = 807 → Output: [7,0,8]."
  },
  {
    "question": "Add Two Numbers II (LeetCode – follow-up of above). Unlike the previous version, the digits are stored in forward order. Add the two numbers and return the sum as a linked list.",
    "answer": "import java.util.Stack;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class AddTwoNumbersII {\n\n    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<Integer> s2 = new Stack<>();\n\n        // Push all values of l1 into s1\n        while (l1 != null) {\n            s1.push(l1.val);\n            l1 = l1.next;\n        }\n        // Push all values of l2 into s2\n        while (l2 != null) {\n            s2.push(l2.val);\n            l2 = l2.next;\n        }\n\n        int carry = 0;\n        ListNode head = null;\n\n        // Pop from both stacks and add\n        while (!s1.isEmpty() || !s2.isEmpty() || carry > 0) {\n            int sum = carry;\n            if (!s1.isEmpty()) sum += s1.pop();\n            if (!s2.isEmpty()) sum += s2.pop();\n            ListNode node = new ListNode(sum % 10);\n            node.next = head;\n            head = node;\n            carry = sum / 10;\n        }\n        return head;\n    }\n\n    public static void main(String[] args) {\n        // Example: 7243 + 564 = 7807\n        ListNode l1 = new ListNode(7);\n        l1.next = new ListNode(2);\n        l1.next.next = new ListNode(4);\n        l1.next.next.next = new ListNode(3);\n\n        ListNode l2 = new ListNode(5);\n        l2.next = new ListNode(6);\n        l2.next.next = new ListNode(4);\n\n        ListNode result = addTwoNumbers(l1, l2);\n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n",
    "input": "l1 = [7,2,4,3], l2 = [5,6,4]",
    "output": "[7,8,0,7]",
    "explanation": "We use stacks to handle digits in reverse, add them, and build the result in forward order. Example: 7243 + 564 = 7807 → Output: [7,8,0,7]."
  },
  {
    "question": "Delete the Middle Node of a Linked List (LeetCode). Given the head of a linked list, delete the middle node and return the modified list.",
    "answer": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class DeleteMiddleNode {\n\n    public static ListNode deleteMiddle(ListNode head) {\n        if (head == null || head.next == null) return null;\n\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode prev = null;\n\n        // Move fast 2 steps and slow 1 step\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            prev = slow;\n            slow = slow.next;\n        }\n\n        // Delete the middle node\n        prev.next = slow.next;\n        return head;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n\n        ListNode result = deleteMiddle(head);\n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n",
    "input": "[1,2,3,4]",
    "output": "[1,2,4]",
    "explanation": "We use the fast & slow pointer technique to find the middle node and remove it. For input [1,2,3,4], the middle is 3 → Output: [1,2,4]."
  },
  {
    "question": "Rotate List (LeetCode Microsoft). Given the head of a linked list, rotate the list to the right by k places.",
    "answer": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class RotateList {\n\n    public static ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n\n        // Find the length of the list\n        ListNode curr = head;\n        int length = 1;\n        while (curr.next != null) {\n            curr = curr.next;\n            length++;\n        }\n\n        // Connect tail to head to form a circle\n        curr.next = head;\n\n        // Find the new head position\n        k = k % length;\n        int stepsToNewHead = length - k;\n        ListNode newTail = curr;\n\n        while (stepsToNewHead-- > 0) {\n            newTail = newTail.next;\n        }\n\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        return newHead;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n\n        ListNode result = rotateRight(head, 2);\n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n",
    "input": "[1,2,3,4,5], k=2",
    "output": "[4,5,1,2,3]",
    "explanation": "We form a circular linked list and then break it at the right position. Example: [1,2,3,4,5] rotated by 2 → [4,5,1,2,3]."
  },
  {
    "question": "Reverse Nodes in k-Group (LeetCode). Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. If the number of nodes is not a multiple of k then left-out nodes remain as is.",
    "answer": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class ReverseKGroup {\n\n    public static ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || k == 1) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode curr = dummy, nex = dummy, pre = dummy;\n        \n        // Count length of list\n        int count = 0;\n        while (curr.next != null) {\n            curr = curr.next;\n            count++;\n        }\n\n        // Reverse in groups of k\n        while (count >= k) {\n            curr = pre.next;\n            nex = curr.next;\n            for (int i = 1; i < k; i++) {\n                curr.next = nex.next;\n                nex.next = pre.next;\n                pre.next = nex;\n                nex = curr.next;\n            }\n            pre = curr;\n            count -= k;\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n\n        ListNode result = reverseKGroup(head, 2);\n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n",
    "input": "[1,2,3,4,5], k=2",
    "output": "[2,1,4,3,5]",
    "explanation": "We reverse nodes in groups of k by rearranging links. Example: k=2 → swap every two nodes. Input [1,2,3,4,5] → [2,1,4,3,5]."
  },
  {
    "question": "Flatten a Multilevel Doubly Linked List (LeetCode Amazon). Each node has 'next', 'prev', and 'child' pointers. Flatten the list so that all nodes appear in a single-level doubly linked list.",
    "answer": "class Node {\n    int val;\n    Node prev;\n    Node next;\n    Node child;\n    Node(int x) { val = x; }\n}\n\npublic class FlattenList {\n\n    public static Node flatten(Node head) {\n        if (head == null) return head;\n        Node dummy = new Node(0);\n        dummy.next = head;\n        flattenDFS(dummy, head);\n        dummy.next.prev = null;\n        return dummy.next;\n    }\n\n    private static Node flattenDFS(Node prev, Node curr) {\n        if (curr == null) return prev;\n        curr.prev = prev;\n        prev.next = curr;\n\n        Node tempNext = curr.next;\n        Node tail = flattenDFS(curr, curr.child);\n        curr.child = null;\n\n        return flattenDFS(tail, tempNext);\n    }\n}\n",
    "input": "1 - 2 - 3\n          |\n          7 - 8",
    "output": "1-2-3-7-8",
    "explanation": "We use DFS to link child lists inline, then continue with next. Example: 1→2→3 with child 7→8 becomes 1→2→3→7→8."
  },
  {
    "question": "Clone a Linked List with Random Pointer (LeetCode / GFG). A linked list is given where each node contains a next pointer and a random pointer. Clone the list with both next and random pointers.",
    "answer": "class RandomNode {\n    int val;\n    RandomNode next;\n    RandomNode random;\n    RandomNode(int x) { val = x; }\n}\n\npublic class CloneRandomList {\n\n    public static RandomNode copyRandomList(RandomNode head) {\n        if (head == null) return null;\n\n        // Step 1: Insert cloned nodes\n        RandomNode curr = head;\n        while (curr != null) {\n            RandomNode clone = new RandomNode(curr.val);\n            clone.next = curr.next;\n            curr.next = clone;\n            curr = clone.next;\n        }\n\n        // Step 2: Copy random pointers\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n\n        // Step 3: Separate the cloned list\n        curr = head;\n        RandomNode dummy = new RandomNode(0);\n        RandomNode copy = dummy;\n        while (curr != null) {\n            copy.next = curr.next;\n            curr.next = curr.next.next;\n            curr = curr.next;\n            copy = copy.next;\n        }\n\n        return dummy.next;\n    }\n}\n",
    "input": "1 -> 2 (random: 1→2, 2→1)",
    "output": "1' -> 2' (random: 1'→2', 2'→1')",
    "explanation": "We insert cloned nodes between originals, assign random pointers, then split lists. This avoids extra space (O(1))."
  },
  {
    "question": "Merge k Sorted Lists (LeetCode). You are given an array of k linked-lists, each sorted in ascending order. Merge all the linked-lists into one sorted linked list and return it.",
    "answer": "import java.util.PriorityQueue;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class MergeKLists {\n\n    public static ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n        // Add first node of each list\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n\n        ListNode dummy = new ListNode(0);\n        ListNode tail = dummy;\n\n        while (!pq.isEmpty()) {\n            ListNode min = pq.poll();\n            tail.next = min;\n            tail = tail.next;\n            if (min.next != null) pq.add(min.next);\n        }\n\n        return dummy.next;\n    }\n}\n",
    "input": "[[1,4,5],[1,3,4],[2,6]]",
    "output": "[1,1,2,3,4,4,5,6]",
    "explanation": "We use a min-heap (priority queue) to always pick the smallest head among lists, appending it to result. Runs in O(N log k)."
  },
  {
    "question": "LRU Cache (LeetCode – must-know system design + Linked List + HashMap). Design a data structure that supports get and put operations in O(1) time using LRU eviction policy.",
    "answer": "import java.util.*;\n\nclass LRUCache {\n    class Node {\n        int key, value;\n        Node prev, next;\n        Node(int k, int v) { key = k; value = v; }\n    }\n\n    private Map<Integer, Node> map;\n    private int capacity;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(0,0);\n        tail = new Node(0,0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    // Remove node from list\n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    // Insert node at front\n    private void insert(Node node) {\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        node.prev = head;\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            remove(node);\n            insert(node);\n            return node.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            remove(map.get(key));\n        }\n        if (map.size() == capacity) {\n            map.remove(tail.prev.key);\n            remove(tail.prev);\n        }\n        Node node = new Node(key, value);\n        insert(node);\n        map.put(key, node);\n    }\n}\n",
    "input": "[[\"LRUCache\",[2]],[\"put\",[1,1]],[\"put\",[2,2]],[\"get\",[1]],[\"put\",[3,3]],[\"get\",[2]],[\"put\",[4,4]],[\"get\",[1]],[\"get\",[3]],[\"get\",[4]]]",
    "output": "[null,null,null,1,null,-1,null,-1,3,4]",
    "explanation": "We use HashMap for O(1) lookup and Doubly Linked List to maintain usage order. Eviction removes least recently used node."
  }
]