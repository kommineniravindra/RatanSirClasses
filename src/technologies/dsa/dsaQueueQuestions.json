[
  {
    "question": "Implement a queue data structure using arrays in Java. The queue should support standard operations like enqueue, dequeue, peek, and checking if it is empty or full.",
    "answer": "public class ArrayQueue {\n    private int[] queue;\n    private int front, rear, size, capacity;\n\n    // Constructor to initialize queue\n    public ArrayQueue(int capacity) {\n        this.capacity = capacity;\n        queue = new int[capacity];\n        front = 0;\n        rear = -1;\n        size = 0;\n    }\n\n    // Add element to the rear\n    public void enqueue(int value) {\n        if (size == capacity) {\n            System.out.println(\"Queue Overflow\");\n            return;\n        }\n        rear = (rear + 1) % capacity;\n        queue[rear] = value;\n        size++;\n    }\n\n    // Remove element from the front\n    public int dequeue() {\n        if (size == 0) {\n            System.out.println(\"Queue Underflow\");\n            return -1;\n        }\n        int val = queue[front];\n        front = (front + 1) % capacity;\n        size--;\n        return val;\n    }\n\n    // Peek front element\n    public int peek() {\n        if (size == 0) {\n            System.out.println(\"Queue is empty\");\n            return -1;\n        }\n        return queue[front];\n    }\n\n    // Check if queue is empty\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public static void main(String[] args) {\n        ArrayQueue q = new ArrayQueue(5);\n        q.enqueue(10);\n        q.enqueue(20);\n        q.enqueue(30);\n        System.out.println(\"Front element: \" + q.peek());\n        System.out.println(\"Dequeued: \" + q.dequeue());\n        System.out.println(\"Is empty? \" + q.isEmpty());\n    }\n}\n",
    "input": "Enqueue 10,20,30; Dequeue; Peek",
    "output": "Front element: 10\nDequeued: 10\nIs empty? false",
    "explanation": "We implement a queue using a circular array. rear and front are updated modulo capacity for wrap-around. Enqueue adds at rear, dequeue removes from front, and peek reads front element."
  },
  {
    "question": "Implement a queue data structure using a linked list in Java. The queue should support enqueue, dequeue, peek, and checking if it is empty, using dynamic memory allocation.",
    "answer": "class LinkedListQueue {\n\n    // Node class for linked list\n    private static class Node {\n        int data;\n        Node next;\n        Node(int data) { this.data = data; }\n    }\n\n    private Node front, rear;\n\n    // Add element to the rear\n    public void enqueue(int value) {\n        Node newNode = new Node(value);\n        if (rear != null) rear.next = newNode;\n        rear = newNode;\n        if (front == null) front = rear;\n    }\n\n    // Remove element from the front\n    public int dequeue() {\n        if (front == null) {\n            System.out.println(\"Queue Underflow\");\n            return -1;\n        }\n        int val = front.data;\n        front = front.next;\n        if (front == null) rear = null;\n        return val;\n    }\n\n    // Peek front element\n    public int peek() {\n        if (front == null) {\n            System.out.println(\"Queue is empty\");\n            return -1;\n        }\n        return front.data;\n    }\n\n    // Check if queue is empty\n    public boolean isEmpty() {\n        return front == null;\n    }\n\n    public static void main(String[] args) {\n        LinkedListQueue q = new LinkedListQueue();\n        q.enqueue(10);\n        q.enqueue(20);\n        q.enqueue(30);\n        System.out.println(\"Front element: \" + q.peek());\n        System.out.println(\"Dequeued: \" + q.dequeue());\n        System.out.println(\"Is empty? \" + q.isEmpty());\n    }\n}\n",
    "input": "Enqueue 10,20,30; Dequeue; Peek",
    "output": "Front element: 10\nDequeued: 10\nIs empty? false",
    "explanation": "We implement a queue using a linked list. Enqueue adds a new node at the rear, dequeue removes the front node, and peek returns the front node's value."
  },
  {
    "question": "Implement a queue using two stacks in Java. The queue should support enqueue, dequeue, and peek operations efficiently using stack operations only.",
    "answer": "import java.util.*;\n\npublic class QueueUsingStacks {\n    private Stack<Integer> s1 = new Stack<>();\n    private Stack<Integer> s2 = new Stack<>();\n\n    // Add element to the queue\n    public void enqueue(int x) {\n        s1.push(x);\n    }\n\n    // Remove element from the queue\n    public int dequeue() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) s2.push(s1.pop());\n        }\n        if (s2.isEmpty()) {\n            System.out.println(\"Queue Underflow\");\n            return -1;\n        }\n        return s2.pop();\n    }\n\n    // Peek front element\n    public int peek() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) s2.push(s1.pop());\n        }\n        if (s2.isEmpty()) {\n            System.out.println(\"Queue is empty\");\n            return -1;\n        }\n        return s2.peek();\n    }\n\n    public static void main(String[] args) {\n        QueueUsingStacks q = new QueueUsingStacks();\n        q.enqueue(10);\n        q.enqueue(20);\n        q.enqueue(30);\n        System.out.println(\"Front element: \" + q.peek());\n        System.out.println(\"Dequeued: \" + q.dequeue());\n        System.out.println(\"Front element after dequeue: \" + q.peek());\n    }\n}\n",
    "input": "Enqueue 10,20,30; Dequeue; Peek",
    "output": "Front element: 10\nDequeued: 10\nFront element after dequeue: 20",
    "explanation": "We use two stacks: s1 for enqueue and s2 for dequeue. When s2 is empty, we transfer all elements from s1 to s2, reversing their order to maintain queue behavior."
  },
  {
    "question": "Design a circular queue in Java that supports enqueue, dequeue, peek, checking if empty or full, and uses an array in a circular manner for efficient space utilization.",
    "answer": "public class CircularQueue {\n    private int[] queue;\n    private int front, rear, size, capacity;\n\n    // Constructor to initialize circular queue\n    public CircularQueue(int capacity) {\n        this.capacity = capacity;\n        queue = new int[capacity];\n        front = 0;\n        rear = -1;\n        size = 0;\n    }\n\n    // Add element to the queue\n    public void enqueue(int value) {\n        if (size == capacity) {\n            System.out.println(\"Queue Overflow\");\n            return;\n        }\n        rear = (rear + 1) % capacity;\n        queue[rear] = value;\n        size++;\n    }\n\n    // Remove element from the queue\n    public int dequeue() {\n        if (size == 0) {\n            System.out.println(\"Queue Underflow\");\n            return -1;\n        }\n        int val = queue[front];\n        front = (front + 1) % capacity;\n        size--;\n        return val;\n    }\n\n    // Peek front element\n    public int peek() {\n        if (size == 0) {\n            System.out.println(\"Queue is empty\");\n            return -1;\n        }\n        return queue[front];\n    }\n\n    // Check if queue is empty\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    // Check if queue is full\n    public boolean isFull() {\n        return size == capacity;\n    }\n\n    public static void main(String[] args) {\n        CircularQueue q = new CircularQueue(5);\n        q.enqueue(10);\n        q.enqueue(20);\n        q.enqueue(30);\n        System.out.println(\"Front element: \" + q.peek());\n        System.out.println(\"Dequeued: \" + q.dequeue());\n        System.out.println(\"Is full? \" + q.isFull());\n    }\n}\n",
    "input": "Enqueue 10,20,30; Dequeue; Peek; IsFull",
    "output": "Front element: 10\nDequeued: 10\nIs full? false",
    "explanation": "We implement a circular queue using an array. front and rear are updated modulo capacity. Enqueue adds at rear, dequeue removes from front, peek reads front, and size tracks the number of elements."
  },
  {
    "question": "Implement a class that counts the number of recent calls within a time frame (e.g., last 3000 milliseconds). Use a queue to store timestamps and efficiently count recent calls.",
    "answer": "import java.util.*;\n\nclass RecentCounter {\n    private Queue<Integer> queue;\n\n    // Constructor to initialize the queue\n    public RecentCounter() {\n        queue = new LinkedList<>();\n    }\n\n    // Add a new call timestamp and count calls within last 3000 ms\n    public int ping(int t) {\n        queue.add(t);\n        while (!queue.isEmpty() && queue.peek() < t - 3000) {\n            queue.poll();\n        }\n        return queue.size();\n    }\n\n    public static void main(String[] args) {\n        RecentCounter rc = new RecentCounter();\n        System.out.println(rc.ping(1));    // 1\n        System.out.println(rc.ping(100));  // 2\n        System.out.println(rc.ping(3001)); // 3\n        System.out.println(rc.ping(3002)); // 3\n    }\n}\n",
    "input": "[1,100,3001,3002]",
    "output": "[1,2,3,3]",
    "explanation": "We use a queue to store timestamps of calls. When a new call arrives, we remove timestamps older than 3000ms and return the current size of the queue as the number of recent calls."
  },
  {
    "question": "Given a queue, reverse the first K elements while keeping the rest of the elements in the same order. Use a stack to reverse the elements efficiently.",
    "answer": "import java.util.*;\n\npublic class ReverseKQueue {\n    public static void reverseKElements(Queue<Integer> queue, int k) {\n        if (queue.isEmpty() || k <= 0) return;\n\n        Stack<Integer> stack = new Stack<>();\n        // Step 1: Push first k elements into stack\n        for (int i = 0; i < k; i++) {\n            stack.push(queue.poll());\n        }\n\n        // Step 2: Enqueue stack elements back to queue\n        while (!stack.isEmpty()) {\n            queue.add(stack.pop());\n        }\n\n        // Step 3: Move remaining elements to back to maintain order\n        int size = queue.size();\n        for (int i = 0; i < size - k; i++) {\n            queue.add(queue.poll());\n        }\n    }\n\n    public static void main(String[] args) {\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(1,2,3,4,5));\n        reverseKElements(q, 3);\n        System.out.println(q); // [3,2,1,4,5]\n    }\n}\n",
    "input": "[1,2,3,4,5], k=3",
    "output": "[3,2,1,4,5]",
    "explanation": "We use a stack to reverse the first K elements. Remaining elements are dequeued and enqueued again to maintain their original order."
  },
  {
    "question": "Given an array, find the next smaller element for each element. If there is no smaller element to the right, use -1. Use a stack to efficiently find the next smaller element in linear time.",
    "answer": "import java.util.*;\n\npublic class NextSmallerElement {\n    public static int[] nextSmaller(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() >= nums[i]) {\n                stack.pop();\n            }\n            result[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(nums[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 5, 2, 10, 8};\n        System.out.println(Arrays.toString(nextSmaller(arr))); // [2,2,-1,8,-1]\n    }\n}\n",
    "input": "[4,5,2,10,8]",
    "output": "[2,2,-1,8,-1]",
    "explanation": "We use a stack to store potential next smaller elements. Traversing from right to left ensures each elementâ€™s next smaller element is found in O(n) time."
  },
  {
    "question": "Given a circular array, find the next greater element for each element. If there is no greater element, return -1. Use a stack to solve this efficiently in linear time.",
    "answer": "import java.util.*;\n\npublic class NextGreaterElementII {\n    public static int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < 2 * n; i++) {\n            int num = nums[i % n];\n            while (!stack.isEmpty() && nums[stack.peek()] < num) {\n                result[stack.pop()] = num;\n            }\n            if (i < n) stack.push(i);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1,2,1};\n        System.out.println(Arrays.toString(nextGreaterElements(nums))); // [2,-1,2]\n    }\n}\n",
    "input": "[1,2,1]",
    "output": "[2,-1,2]",
    "explanation": "We use a stack to store indices of elements whose next greater element hasn't been found. Traversing twice handles the circular nature of the array, achieving O(n) time."
  },
  {
    "question": "Given a non-negative integer represented as a string, remove k digits from the number so that the resulting number is the smallest possible. Use a stack to maintain the digits efficiently.",
    "answer": "import java.util.*;\n\npublic class RemoveKDigits {\n    public static String removeKdigits(String num, int k) {\n        Stack<Character> stack = new Stack<>();\n        for (char digit : num.toCharArray()) {\n            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {\n                stack.pop();\n                k--;\n            }\n            stack.push(digit);\n        }\n        // Remove remaining digits from the end\n        while (k > 0 && !stack.isEmpty()) {\n            stack.pop();\n            k--;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : stack) sb.append(c);\n        // Remove leading zeros\n        while (sb.length() > 1 && sb.charAt(0) == '0') sb.deleteCharAt(0);\n        return sb.length() == 0 ? \"0\" : sb.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(removeKdigits(\"1432219\", 3)); // \"1219\"\n    }\n}\n",
    "input": "\"1432219\", k=3",
    "output": "\"1219\"",
    "explanation": "We use a stack to maintain a monotone increasing sequence. If a new digit is smaller than the top, we pop from the stack until the condition is satisfied, ensuring the smallest number possible."
  },
  {
    "question": "Given an array of integers, find the sum of the minimum element of every subarray. Use a stack to efficiently compute the contribution of each element as the minimum.",
    "answer": "import java.util.*;\n\npublic class SumOfSubarrayMinimums {\n    public static int sumSubarrayMins(int[] arr) {\n        int n = arr.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Stack<Integer> stack = new Stack<>();\n\n        // Previous Less Element\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) stack.pop();\n            left[i] = stack.isEmpty() ? i + 1 : i - stack.peek();\n            stack.push(i);\n        }\n\n        stack.clear();\n\n        // Next Less Element\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) stack.pop();\n            right[i] = stack.isEmpty() ? n - i : stack.peek() - i;\n            stack.push(i);\n        }\n\n        long sum = 0;\n        int MOD = 1000000007;\n        for (int i = 0; i < n; i++) {\n            sum = (sum + (long) arr[i] * left[i] * right[i]) % MOD;\n        }\n        return (int) sum;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3,1,2,4};\n        System.out.println(sumSubarrayMins(arr)); // 17\n    }\n}\n",
    "input": "[3,1,2,4]",
    "output": "17",
    "explanation": "We compute for each element the number of subarrays where it is the minimum using stacks for previous and next less elements. Multiplying contributions gives sum in O(n) time."
  },
  {
    "question": "Given a 2D image represented by a grid, perform a flood fill from a starting pixel and replace all connected pixels of the same color with a new color. Use BFS (queue) to traverse the connected pixels efficiently.",
    "answer": "import java.util.*;\n\npublic class FloodFill {\n    public static int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int oldColor = image[sr][sc];\n        if (oldColor == newColor) return image;\n        int m = image.length, n = image[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{sr, sc});\n        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\n\n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            int r = cell[0], c = cell[1];\n            image[r][c] = newColor;\n            for (int[] d : directions) {\n                int nr = r + d[0], nc = c + d[1];\n                if (nr >=0 && nr < m && nc >=0 && nc < n && image[nr][nc] == oldColor) {\n                    queue.add(new int[]{nr, nc});\n                }\n            }\n        }\n        return image;\n    }\n\n    public static void main(String[] args) {\n        int[][] image = {{1,1,1},{1,1,0},{1,0,1}};\n        int[][] res = floodFill(image, 1, 1, 2);\n        for(int[] row : res) System.out.println(Arrays.toString(row));\n    }\n}\n",
    "input": "[[1,1,1],[1,1,0],[1,0,1]], sr=1, sc=1, newColor=2",
    "output": "[[2,2,2],[2,2,0],[2,0,1]]",
    "explanation": "We perform BFS using a queue to traverse all pixels connected 4-directionally that have the same color as the starting pixel, and update them to the new color."
  },
  {
    "question": "Given a grid representing oranges, where 0 = empty, 1 = fresh, 2 = rotten, determine the minimum number of minutes until all oranges become rotten. Use BFS to spread rot level by level.",
    "answer": "import java.util.*;\n\npublic class RottenOranges {\n    public static int orangesRotting(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        int fresh = 0;\n\n        // Initialize queue with rotten oranges\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) queue.add(new int[]{i,j});\n                if (grid[i][j] == 1) fresh++;\n            }\n        }\n\n        if (fresh == 0) return 0;\n        int minutes = 0;\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            boolean rotted = false;\n            for (int i = 0; i < size; i++) {\n                int[] cell = queue.poll();\n                for (int[] d : dirs) {\n                    int r = cell[0] + d[0], c = cell[1] + d[1];\n                    if (r >=0 && r < m && c >=0 && c < n && grid[r][c] == 1) {\n                        grid[r][c] = 2;\n                        queue.add(new int[]{r,c});\n                        fresh--;\n                        rotted = true;\n                    }\n                }\n            }\n            if (rotted) minutes++;\n        }\n        return fresh == 0 ? minutes : -1;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {{2,1,1},{1,1,0},{0,1,1}};\n        System.out.println(orangesRotting(grid)); // 4\n    }\n}\n",
    "input": "[[2,1,1],[1,1,0],[0,1,1]]",
    "output": "4",
    "explanation": "We perform BFS starting from all initially rotten oranges. At each minute, rot spreads to adjacent fresh oranges. The process continues until no fresh oranges remain or it's impossible to rot all."
  },
  {
    "question": "Given a list of tasks represented by characters and a cooldown period n, determine the minimum time required to execute all tasks such that the same tasks are separated by at least n intervals. Use a priority queue and queue to simulate the scheduling.",
    "answer": "import java.util.*;\n\npublic class TaskScheduler {\n    public static int leastInterval(char[] tasks, int n) {\n        int[] count = new int[26];\n        for (char task : tasks) count[task - 'A']++;\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n        for (int c : count) if (c > 0) pq.add(c);\n\n        Queue<int[]> cooldown = new LinkedList<>();\n        int time = 0;\n\n        while (!pq.isEmpty() || !cooldown.isEmpty()) {\n            time++;\n            if (!pq.isEmpty()) {\n                int current = pq.poll() - 1;\n                if (current > 0) cooldown.add(new int[]{current, time + n});\n            }\n            if (!cooldown.isEmpty() && cooldown.peek()[1] == time) {\n                pq.add(cooldown.poll()[0]);\n            }\n        }\n        return time;\n    }\n\n    public static void main(String[] args) {\n        char[] tasks = {'A','A','A','B','B','B'};\n        int n = 2;\n        System.out.println(leastInterval(tasks, n)); // 8\n    }\n}\n",
    "input": "tasks=['A','A','A','B','B','B'], n=2",
    "output": "8",
    "explanation": "We use a max-heap to always execute the task with highest remaining count, and a queue to track tasks in cooldown. Each time unit, we process available tasks and manage cooldown to ensure spacing."
  },
  {
    "question": "Given a binary tree, return the values of the nodes visible from the right side using BFS (level order traversal).",
    "answer": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class RightSideView {\n    public static List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (i == size - 1) res.add(node.val);\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.right = new TreeNode(5);\n        root.right.right = new TreeNode(4);\n        System.out.println(rightSideView(root)); // [1,3,4]\n    }\n}\n",
    "input": "Binary Tree [1,2,3,null,5,null,4]",
    "output": "[1,3,4]",
    "explanation": "We perform BFS level by level and pick the last node of each level to get the right-side view."
  },
  {
    "question": "Solve the 'Snake and Ladders' game using BFS. Given a board, find the minimum number of moves to reach the last cell. Use a queue to explore reachable positions efficiently.",
    "answer": "import java.util.*;\n\npublic class SnakeAndLadders {\n    public static int snakesAndLadders(int[][] board) {\n        int n = board.length;\n        boolean[] visited = new boolean[n*n];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        visited[0] = true;\n        int moves = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int pos = queue.poll();\n                if (pos == n*n - 1) return moves;\n                for (int next = pos + 1; next <= Math.min(pos + 6, n*n - 1); next++) {\n                    int r = n - 1 - next / n;\n                    int c = (r % 2 != n % 2) ? next % n : n - 1 - next % n;\n                    int dest = board[r][c] == -1 ? next : board[r][c] - 1;\n                    if (!visited[dest]) {\n                        visited[dest] = true;\n                        queue.add(dest);\n                    }\n                }\n            }\n            moves++;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[][] board = {\n            {-1,-1,-1,-1,-1,-1},\n            {-1,-1,-1,-1,-1,-1},\n            {-1,-1,-1,-1,-1,-1},\n            {-1,35,-1,-1,13,-1},\n            {-1,-1,-1,-1,-1,-1},\n            {-1,15,-1,-1,-1,-1}\n        };\n        System.out.println(snakesAndLadders(board)); // 4\n    }\n}\n",
    "input": "board as above",
    "output": "4",
    "explanation": "We use BFS to explore all reachable positions from the current cell with a dice roll of 1-6. Ladders and snakes modify the target position, and BFS ensures minimum moves."
  },
  {
    "question": "Given arrays representing petrol at each station and distance to next station, determine if a circular tour is possible starting from any petrol pump. Use a queue/greedy approach to check feasibility efficiently.",
    "answer": "public class CircularTour {\n    public static int tour(int[] petrol, int[] distance) {\n        int n = petrol.length;\n        int start = 0, balance = 0, deficit = 0;\n\n        for (int i = 0; i < n; i++) {\n            balance += petrol[i] - distance[i];\n            if (balance < 0) {\n                start = i + 1;\n                deficit += balance;\n                balance = 0;\n            }\n        }\n        return balance + deficit >= 0 ? start : -1;\n    }\n\n    public static void main(String[] args) {\n        int[] petrol = {4,6,7,4};\n        int[] distance = {6,5,3,5};\n        System.out.println(tour(petrol, distance)); // 1\n    }\n}\n",
    "input": "petrol=[4,6,7,4], distance=[6,5,3,5]",
    "output": "1",
    "explanation": "We traverse each station, maintaining balance of petrol. If balance becomes negative, we shift start to next station and accumulate deficit. If total balance + deficit >=0, a circular tour is possible."
  },
  {
    "question": "Given an integer array and a window size k, find the maximum in each sliding window of size k. Use a deque to maintain indices of potential maximum elements for optimal performance.",
    "answer": "import java.util.*;\n\npublic class SlidingWindowMaximum {\n    public static int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || k <= 0) return new int[0];\n        int n = nums.length;\n        int[] result = new int[n - k + 1];\n        Deque<Integer> deque = new LinkedList<>();\n\n        for (int i = 0; i < n; i++) {\n            // Remove indices out of the current window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) deque.pollFirst();\n\n            // Remove smaller elements as they are not useful\n            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) deque.pollLast();\n\n            deque.offerLast(i);\n\n            // Add max for the current window\n            if (i >= k - 1) result[i - k + 1] = nums[deque.peekFirst()];\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1,3,-1,-3,5,3,6,7};\n        int k = 3;\n        System.out.println(Arrays.toString(maxSlidingWindow(nums, k))); // [3,3,5,5,6,7]\n    }\n}\n",
    "input": "[1,3,-1,-3,5,3,6,7], k=3",
    "output": "[3,3,5,5,6,7]",
    "explanation": "We use a deque to store indices of elements in decreasing order. The front always contains the maximum of the current window, providing O(n) performance."
  },
  {
    "question": "Given a chessboard, find the minimum number of steps for a knight to reach a target position from a starting position using BFS.",
    "answer": "import java.util.*;\n\npublic class KnightMinSteps {\n    public static int minSteps(int N, int startX, int startY, int endX, int endY) {\n        int[][] dirs = {{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}};\n        boolean[][] visited = new boolean[N][N];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{startX, startY, 0});\n        visited[startX][startY] = true;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1], steps = curr[2];\n            if (x == endX && y == endY) return steps;\n            for (int[] d : dirs) {\n                int nx = x + d[0], ny = y + d[1];\n                if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    queue.add(new int[]{nx, ny, steps + 1});\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(minSteps(8, 0, 0, 7, 7)); // 6\n    }\n}\n",
    "input": "N=8, start=(0,0), end=(7,7)",
    "output": "6",
    "explanation": "We use BFS to explore all possible knight moves level by level, ensuring the first time we reach the target is the minimum number of steps."
  },
  {
    "question": "Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and connected horizontally or vertically. Use BFS to traverse each island.",
    "answer": "import java.util.*;\n\npublic class NumIslands {\n    public static int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        int m = grid.length, n = grid[0].length;\n        int count = 0;\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    Queue<int[]> queue = new LinkedList<>();\n                    queue.add(new int[]{i,j});\n                    grid[i][j] = '0';\n                    while (!queue.isEmpty()) {\n                        int[] cell = queue.poll();\n                        for (int[] d : dirs) {\n                            int x = cell[0]+d[0], y = cell[1]+d[1];\n                            if (x >=0 && x < m && y >=0 && y < n && grid[x][y] == '1') {\n                                queue.add(new int[]{x,y});\n                                grid[x][y] = '0';\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        char[][] grid = {\n            {'1','1','0','0','0'},\n            {'1','1','0','0','0'},\n            {'0','0','1','0','0'},\n            {'0','0','0','1','1'}\n        };\n        System.out.println(numIslands(grid)); // 3\n    }\n}\n",
    "input": "[[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]]",
    "output": "3",
    "explanation": "We use BFS to traverse all connected lands ('1') starting from each unvisited land, marking them visited to count distinct islands."
  },
  {
    "question": "Design an LRU (Least Recently Used) Cache with get and put operations. Use a combination of a HashMap and a doubly-linked list to achieve O(1) access and updates.",
    "answer": "import java.util.*;\n\nclass LRUCache {\n    private int capacity;\n    private Map<Integer, Node> map;\n    private Node head, tail;\n\n    private static class Node {\n        int key, val;\n        Node prev, next;\n        Node(int k, int v) { key = k; val = v; }\n    }\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(0,0);\n        tail = new Node(0,0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) return -1;\n        Node node = map.get(key);\n        remove(node);\n        insert(node);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            remove(map.get(key));\n        }\n        Node node = new Node(key,value);\n        insert(node);\n        map.put(key,node);\n        if (map.size() > capacity) {\n            Node lru = head.next;\n            remove(lru);\n            map.remove(lru.key);\n        }\n    }\n\n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void insert(Node node) {\n        node.prev = tail.prev;\n        node.next = tail;\n        tail.prev.next = node;\n        tail.prev = node;\n    }\n\n    public static void main(String[] args) {\n        LRUCache cache = new LRUCache(2);\n        cache.put(1,1);\n        cache.put(2,2);\n        System.out.println(cache.get(1)); // 1\n        cache.put(3,3);\n        System.out.println(cache.get(2)); // -1\n        cache.put(4,4);\n        System.out.println(cache.get(1)); // -1\n        System.out.println(cache.get(3)); // 3\n        System.out.println(cache.get(4)); // 4\n    }\n}\n",
    "input": "Capacity=2; put(1,1), put(2,2), get(1), put(3,3), get(2), put(4,4), get(1), get(3), get(4)",
    "output": "[1,-1,-1,3,4]",
    "explanation": "We use a HashMap for O(1) access and a doubly-linked list to maintain LRU order. On each get or put, accessed nodes are moved to the end to mark them as recently used."
  }
]