[
  {
    "question": "Implement a stack data structure using arrays in Java. The stack should support standard operations like push, pop, peek, and checking if it is empty.",
    "answer": "public class ArrayStack {\n    private int[] stack;\n    private int top;\n    private int capacity;\n\n    // Constructor to initialize stack\n    public ArrayStack(int size) {\n        capacity = size;\n        stack = new int[capacity];\n        top = -1;\n    }\n\n    // Push element onto stack\n    public void push(int value) {\n        if (top == capacity - 1) {\n            System.out.println(\"Stack Overflow\");\n            return;\n        }\n        stack[++top] = value;\n    }\n\n    // Pop element from stack\n    public int pop() {\n        if (top == -1) {\n            System.out.println(\"Stack Underflow\");\n            return -1;\n        }\n        return stack[top--];\n    }\n\n    // Peek top element\n    public int peek() {\n        if (top == -1) {\n            System.out.println(\"Stack is empty\");\n            return -1;\n        }\n        return stack[top];\n    }\n\n    // Check if stack is empty\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    public static void main(String[] args) {\n        ArrayStack stack = new ArrayStack(5);\n        stack.push(10);\n        stack.push(20);\n        stack.push(30);\n        System.out.println(\"Top element: \" + stack.peek());\n        System.out.println(\"Popped element: \" + stack.pop());\n        System.out.println(\"Is stack empty? \" + stack.isEmpty());\n    }\n}\n",
    "input": "Push 10, 20, 30; Pop; Peek",
    "output": "Top element: 30\nPopped element: 30\nIs stack empty? false",
    "explanation": "We implement a stack using an array. top keeps track of the last element. Push increments top, pop decrements it, and peek returns the current top."
  },
  {
    "question": "Implement a stack data structure using a linked list in Java. The stack should support push, pop, peek, and checking if the stack is empty, utilizing a linked list for dynamic memory allocation.",
    "answer": "class LinkedListStack {\n\n    // Node class for linked list\n    private static class Node {\n        int data;\n        Node next;\n\n        Node(int data) {\n            this.data = data;\n        }\n    }\n\n    private Node top;\n\n    // Push element onto stack\n    public void push(int value) {\n        Node newNode = new Node(value);\n        newNode.next = top;\n        top = newNode;\n    }\n\n    // Pop element from stack\n    public int pop() {\n        if (top == null) {\n            System.out.println(\"Stack Underflow\");\n            return -1;\n        }\n        int value = top.data;\n        top = top.next;\n        return value;\n    }\n\n    // Peek top element\n    public int peek() {\n        if (top == null) {\n            System.out.println(\"Stack is empty\");\n            return -1;\n        }\n        return top.data;\n    }\n\n    // Check if stack is empty\n    public boolean isEmpty() {\n        return top == null;\n    }\n\n    public static void main(String[] args) {\n        LinkedListStack stack = new LinkedListStack();\n        stack.push(10);\n        stack.push(20);\n        stack.push(30);\n        System.out.println(\"Top element: \" + stack.peek());\n        System.out.println(\"Popped element: \" + stack.pop());\n        System.out.println(\"Is stack empty? \" + stack.isEmpty());\n    }\n}\n",
    "input": "Push 10, 20, 30; Pop; Peek",
    "output": "Top element: 30\nPopped element: 30\nIs stack empty? false",
    "explanation": "We use a linked list to implement a stack. Push inserts a new node at the top, pop removes the top node, and peek reads the top node's value."
  },
  {
    "question": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if all types of brackets are closed in the correct order using stack operations.",
    "answer": "import java.util.*;\n\npublic class ValidParentheses {\n    public static boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(') stack.push(')');\n            else if (c == '{') stack.push('}');\n            else if (c == '[') stack.push(']');\n            else {\n                if (stack.isEmpty() || stack.pop() != c) return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        String input = \"({[]})\";\n        System.out.println(\"Is valid? \" + isValid(input));\n    }\n}\n",
    "input": "({[]})",
    "output": "Is valid? true",
    "explanation": "We use a stack to keep track of expected closing brackets. For every opening bracket, we push the corresponding closing bracket. For each closing bracket, we check if it matches the top of the stack."
  },
  {
    "question": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement this 'Min Stack' in Java using two stacks for optimal performance.",
    "answer": "import java.util.*;\n\npublic class MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    // Push element onto stack\n    public void push(int x) {\n        stack.push(x);\n        if (minStack.isEmpty() || x <= minStack.peek()) {\n            minStack.push(x);\n        }\n    }\n\n    // Pop element from stack\n    public void pop() {\n        int x = stack.pop();\n        if (x == minStack.peek()) {\n            minStack.pop();\n        }\n    }\n\n    // Peek top element\n    public int top() {\n        return stack.peek();\n    }\n\n    // Retrieve minimum element\n    public int getMin() {\n        return minStack.peek();\n    }\n\n    public static void main(String[] args) {\n        MinStack minStack = new MinStack();\n        minStack.push(3);\n        minStack.push(5);\n        System.out.println(\"Current min: \" + minStack.getMin());\n        minStack.push(2);\n        minStack.push(1);\n        System.out.println(\"Current min: \" + minStack.getMin());\n        minStack.pop();\n        System.out.println(\"Top element: \" + minStack.top());\n        System.out.println(\"Current min: \" + minStack.getMin());\n    }\n}\n",
    "input": "Push 3,5,2,1; Pop; GetMin",
    "output": "Current min: 3\nCurrent min: 1\nTop element: 2\nCurrent min: 2",
    "explanation": "We use two stacks: one to store all elements and another to store the minimum elements. Push and pop are adjusted to maintain the min stack, allowing retrieval of minimum in O(1) time."
  },
  {
    "question": "Given a stack of integers, delete the middle element of the stack. If the stack has an even number of elements, delete the lower middle element. Use stack operations and recursion to achieve this efficiently.",
    "answer": "import java.util.*;\n\npublic class DeleteMiddle {\n\n    // Recursive function to delete middle element\n    public static void deleteMiddle(Stack<Integer> stack, int current, int size) {\n        if (stack.isEmpty() || current == size) return;\n\n        int top = stack.pop();\n        deleteMiddle(stack, current + 1, size);\n\n        // Push back all elements except the middle one\n        if (current != size / 2) {\n            stack.push(top);\n        }\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n        stack.push(4);\n        stack.push(5);\n\n        System.out.println(\"Original Stack: \" + stack);\n        deleteMiddle(stack, 0, stack.size());\n        System.out.println(\"Stack after deleting middle: \" + stack);\n    }\n}\n",
    "input": "[1, 2, 3, 4, 5]",
    "output": "[1, 2, 4, 5]",
    "explanation": "We use recursion to pop elements until reaching the middle. We skip pushing the middle element back, effectively deleting it, and push all others back onto the stack."
  },
  {
    "question": "Given an array of integers, find the next greater element for each element in the array. The next greater element for an element x is the first greater element on the right side of x in the array. Use a stack to efficiently solve this problem in linear time.",
    "answer": "import java.util.*;\n\npublic class NextGreaterElement {\n    public static int[] nextGreater(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i]) {\n                stack.pop();\n            }\n            result[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(nums[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {4, 5, 2, 10, 8};\n        System.out.println(\"Next greater elements: \" + Arrays.toString(nextGreater(nums)));\n    }\n}\n",
    "input": "[4, 5, 2, 10, 8]",
    "output": "[5, 10, 10, -1, -1]",
    "explanation": "We traverse the array from right to left. The stack keeps elements for which we are searching for the next greater. We pop smaller or equal elements and the top of the stack becomes the next greater element."
  },
  {
    "question": "Given a valid parentheses string, remove the outermost parentheses of every primitive substring. A primitive substring is non-empty, valid, and cannot be split into two non-empty valid strings. Use a stack to track nested levels and remove outer parentheses efficiently.",
    "answer": "import java.util.*;\n\npublic class RemoveOutermostParentheses {\n    public static String removeOuter(String s) {\n        StringBuilder result = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                if (!stack.isEmpty()) result.append(c);\n                stack.push(c);\n            } else if (c == ')') {\n                stack.pop();\n                if (!stack.isEmpty()) result.append(c);\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        String input = \"(()())(())\";\n        System.out.println(\"After removing outer parentheses: \" + removeOuter(input));\n    }\n}\n",
    "input": "\"(()())(())\"",
    "output": "\"()()()\"",
    "explanation": "We use a stack to keep track of nested levels. Only characters that are not the outermost parentheses (i.e., when stack size > 1) are appended to the result."
  },
  {
    "question": "Given a string, remove all adjacent duplicates repeatedly until no more duplicates remain. Use a stack to efficiently track and remove duplicates in a single pass.",
    "answer": "import java.util.*;\n\npublic class RemoveAdjacentDuplicates {\n    public static String removeDuplicates(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : s.toCharArray()) {\n            if (!stack.isEmpty() && stack.peek() == c) {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n\n        // Build final string\n        StringBuilder sb = new StringBuilder();\n        for (char c : stack) sb.append(c);\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        String input = \"abbaca\";\n        System.out.println(\"After removing duplicates: \" + removeDuplicates(input));\n    }\n}\n",
    "input": "\"abbaca\"",
    "output": "\"ca\"",
    "explanation": "We traverse the string using a stack. If the current character matches the top of the stack, we pop it (remove duplicate). Otherwise, we push it. Finally, the stack contains the result without adjacent duplicates."
  },
   {
    "question": "Perform inorder traversal of a binary tree iteratively using a stack. Inorder traversal visits nodes in the order: left subtree, root, right subtree. Implement this traversal using a stack instead of recursion.",
    "answer": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n}\n\npublic class InorderTraversalIterative {\n    public static List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode current = root;\n\n        while (current != null || !stack.isEmpty()) {\n            // Reach the leftmost node of the current node\n            while (current != null) {\n                stack.push(current);\n                current = current.left;\n            }\n\n            // Current is null at this point\n            current = stack.pop();\n            result.add(current.val);\n\n            // Visit the right subtree\n            current = current.right;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.right = new TreeNode(2);\n        root.right.left = new TreeNode(3);\n\n        System.out.println(\"Inorder traversal: \" + inorderTraversal(root));\n    }\n}\n",
    "input": "Binary tree with root 1, root.right = 2, root.right.left = 3",
    "output": "[1, 3, 2]",
    "explanation": "We use a stack to traverse to the leftmost node, push nodes along the way, then visit nodes and traverse right subtrees. This simulates recursion iteratively."
  },
  {
    "question": "Perform preorder traversal of a binary tree iteratively using a stack. Preorder traversal visits nodes in the order: root, left subtree, right subtree. Implement this traversal using a stack instead of recursion.",
    "answer": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n}\n\npublic class PreorderTraversalIterative {\n    public static List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            result.add(node.val);\n\n            // Push right first so that left is processed first\n            if (node.right != null) stack.push(node.right);\n            if (node.left != null) stack.push(node.left);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.right = new TreeNode(2);\n        root.right.left = new TreeNode(3);\n\n        System.out.println(\"Preorder traversal: \" + preorderTraversal(root));\n    }\n}\n",
    "input": "Binary tree with root 1, root.right = 2, root.right.left = 3",
    "output": "[1, 2, 3]",
    "explanation": "We use a stack to process nodes. Push the right child first and then left child so that the left subtree is processed before the right, simulating preorder traversal iteratively."
  },
  {
    "question": "Evaluate a mathematical expression given in Reverse Polish Notation (postfix notation) using a stack. The expression contains integers and operators (+, -, *, /). Implement evaluation efficiently using a stack.",
    "answer": "import java.util.;\n\npublic class EvaluateRPN {\n    public static int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n\n        for (String token : tokens) {\n            if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"\") || token.equals(\"/\")) {\n                int b = stack.pop();\n                int a = stack.pop();\n                switch (token) {\n                    case \"+\": stack.push(a + b); break;\n                    case \"-\": stack.push(a - b); break;\n                    case \"\": stack.push(a * b); break;\n                    case \"/\": stack.push(a / b); break;\n                }\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n        }\n\n        return stack.pop();\n    }\n\n    public static void main(String[] args) {\n        String[] tokens = {\"2\", \"1\", \"+\", \"3\", \"\"};\n        System.out.println(\"Evaluation result: \" + evalRPN(tokens));\n    }\n}\n",
    "input": "[\"2\", \"1\", \"+\", \"3\", \"*\"]",
    "output": "9",
    "explanation": "We use a stack to push numbers. When an operator is encountered, we pop the top two numbers, perform the operation, and push the result. At the end, the stack contains the evaluated result."
  },
  {
    "question": "Implement a stack using queues in Java. The stack should support standard operations like push, pop, top, and empty using one or two queues efficiently.",
    "answer": "import java.util.*;\n\npublic class StackUsingQueue {\n    private Queue<Integer> queue = new LinkedList<>();\n\n    // Push element onto stack\n    public void push(int x) {\n        queue.add(x);\n        int size = queue.size();\n        // Rotate the queue to put the new element at the front\n        for (int i = 0; i < size - 1; i++) {\n            queue.add(queue.remove());\n        }\n    }\n\n    // Pop element from stack\n    public int pop() {\n        return queue.remove();\n    }\n\n    // Peek top element\n    public int top() {\n        return queue.peek();\n    }\n\n    // Check if stack is empty\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        StackUsingQueue stack = new StackUsingQueue();\n        stack.push(1);\n        stack.push(2);\n        System.out.println(\"Top element: \" + stack.top());\n        System.out.println(\"Popped element: \" + stack.pop());\n        System.out.println(\"Is stack empty? \" + stack.empty());\n    }\n}\n",
    "input": "Push 1, 2; Pop; Top",
    "output": "Top element: 2\nPopped element: 2\nIs stack empty? false",
    "explanation": "We use a queue and rotate it after each push so that the last pushed element is always at the front. This allows queue to behave like a stack efficiently."
  },
  {
    "question": "Given an encoded string, decode it according to the rule k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. Use a stack to decode nested patterns efficiently.",
    "answer": "import java.util.*;\n\npublic class DecodeString {\n    public static String decodeString(String s) {\n        Stack<Integer> countStack = new Stack<>();\n        Stack<String> stringStack = new Stack<>();\n        String current = \"\";\n        int k = 0;\n\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + (c - '0');\n            } else if (c == '[') {\n                countStack.push(k);\n                stringStack.push(current);\n                current = \"\";\n                k = 0;\n            } else if (c == ']') {\n                StringBuilder decoded = new StringBuilder(stringStack.pop());\n                int count = countStack.pop();\n                for (int i = 0; i < count; i++) decoded.append(current);\n                current = decoded.toString();\n            } else {\n                current += c;\n            }\n        }\n\n        return current;\n    }\n\n    public static void main(String[] args) {\n        String input = \"3[a2[c]]\";\n        System.out.println(\"Decoded string: \" + decodeString(input));\n    }\n}\n",
    "input": "\"3[a2[c]]\"",
    "output": "\"accaccacc\"",
    "explanation": "We use two stacks: one to store repeat counts and another to store previous strings. When encountering ']', we pop count and previous string, repeat the current string, and append it back, handling nested patterns."
  },
  {
    "question": "Given an array representing asteroids in a row, each moving either left or right, determine the state of the asteroids after all collisions. Positive numbers move right, negative numbers move left. Use a stack to efficiently simulate collisions.",
    "answer": "import java.util.*;\n\npublic class AsteroidCollision {\n    public static int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n\n        for (int ast : asteroids) {\n            boolean alive = true;\n            while (alive && !stack.isEmpty() && ast < 0 && stack.peek() > 0) {\n                if (stack.peek() < -ast) {\n                    stack.pop();\n                } else if (stack.peek() == -ast) {\n                    stack.pop();\n                    alive = false;\n                } else {\n                    alive = false;\n                }\n            }\n            if (alive) stack.push(ast);\n        }\n\n        int[] result = new int[stack.size()];\n        for (int i = stack.size() - 1; i >= 0; i--) result[i] = stack.pop();\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] asteroids = {5, 10, -5};\n        System.out.println(\"After collision: \" + Arrays.toString(asteroidCollision(asteroids)));\n    }\n}\n",
    "input": "[5, 10, -5]",
    "output": "[5, 10]",
    "explanation": "We use a stack to track alive asteroids. When a left-moving asteroid meets a right-moving one, we resolve collisions by popping smaller ones until the current asteroid is destroyed or placed on the stack."
  },
  {
    "question": "Given an array of integers, find a 132 pattern in it: a subsequence nums[i], nums[j], nums[k] such that i < j < k and nums[i] < nums[k] < nums[j]. Use a stack to find such a pattern efficiently in linear time.",
    "answer": "import java.util.*;\n\npublic class Pattern132 {\n    public static boolean find132pattern(int[] nums) {\n        int n = nums.length;\n        Stack<Integer> stack = new Stack<>();\n        int third = Integer.MIN_VALUE;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (nums[i] < third) return true;\n            while (!stack.isEmpty() && nums[i] > stack.peek()) {\n                third = stack.pop();\n            }\n            stack.push(nums[i]);\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {3, 1, 4, 2};\n        System.out.println(\"132 pattern exists? \" + find132pattern(nums));\n    }\n}\n",
    "input": "[3, 1, 4, 2]",
    "output": "132 pattern exists? true",
    "explanation": "We traverse the array from right to left using a stack to keep potential '3' values and track '2' in a variable. If we find a number smaller than '2', a 132 pattern exists."
  },
  {
    "question": "Given the daily price of a stock, calculate the stock span for each day. The stock span is the number of consecutive days before the current day the price was less than or equal to today’s price. Use a stack to efficiently calculate spans.",
    "answer": "import java.util.*;\n\npublic class StockSpan {\n    public static int[] calculateSpan(int[] prices) {\n        int n = prices.length;\n        int[] span = new int[n];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && prices[stack.peek()] <= prices[i]) {\n                stack.pop();\n            }\n            span[i] = stack.isEmpty() ? i + 1 : i - stack.peek();\n            stack.push(i);\n        }\n\n        return span;\n    }\n\n    public static void main(String[] args) {\n        int[] prices = {100, 80, 60, 70, 60, 75, 85};\n        System.out.println(\"Stock spans: \" + Arrays.toString(calculateSpan(prices)));\n    }\n}\n",
    "input": "[100, 80, 60, 70, 60, 75, 85]",
    "output": "[1, 1, 1, 2, 1, 4, 6]",
    "explanation": "We use a stack to store indices of days with higher prices. For each day, we pop indices with smaller prices and calculate the span as the difference between current index and top of the stack."
  },
  {
    "question": "Convert an infix expression (like 'a+b*c') to postfix notation (like 'abc*+') using a stack. The postfix expression does not require parentheses and preserves the order of operations.",
    "answer": "import java.util.;\n\npublic class InfixToPostfix {\n\n    // Function to get precedence of operators\n    private static int precedence(char op) {\n        if (op == '+' || op == '-') return 1;\n        if (op == '' || op == '/') return 2;\n        return 0;\n    }\n\n    public static String infixToPostfix(String expr) {\n        StringBuilder result = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : expr.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                result.append(c);\n            } else if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                while (!stack.isEmpty() && stack.peek() != '(') {\n                    result.append(stack.pop());\n                }\n                stack.pop(); // pop '('\n            } else {\n                while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {\n                    result.append(stack.pop());\n                }\n                stack.push(c);\n            }\n        }\n\n        while (!stack.isEmpty()) {\n            result.append(stack.pop());\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        String expr = \"a+b*(c-d)\";\n        System.out.println(\"Postfix: \" + infixToPostfix(expr));\n    }\n}\n",
    "input": "\"a+b*(c-d)\"",
    "output": "\"abcd-*+\"",
    "explanation": "We use a stack to store operators and parentheses. Operands are appended to the result directly. Operators are pushed/popped based on precedence to maintain correct order in the postfix expression."
  },
  {
    "question": "Convert a postfix expression (like 'abc*+') back to infix notation (like 'a+b*c') using a stack. The result should include parentheses to preserve the original order of operations.",
    "answer": "import java.util.;\n\npublic class PostfixToInfix {\n    public static String postfixToInfix(String expr) {\n        Stack<String> stack = new Stack<>();\n\n        for (char c : expr.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                stack.push(c + \"\");\n            } else {\n                String b = stack.pop();\n                String a = stack.pop();\n                stack.push(\"(\" + a + c + b + \")\");\n            }\n        }\n\n        return stack.pop();\n    }\n\n    public static void main(String[] args) {\n        String expr = \"abcd-+\";\n        System.out.println(\"Infix: \" + postfixToInfix(expr));\n    }\n}\n",
    "input": "\"abcd-*+\"",
    "output": "\"(a+(b*(c-d)))\"",
    "explanation": "We use a stack to store operands as strings. When an operator is encountered, we pop two operands, combine them with the operator and parentheses, and push back the result."
  },
  {
    "question": "Convert an infix expression (like 'a+b*(c-d)') to prefix notation (like '+a* b c-d') using a stack. The prefix expression places operators before their operands while preserving order of operations.",
    "answer": "import java.util.;\n\npublic class InfixToPrefix {\n\n    // Function to get precedence\n    private static int precedence(char op) {\n        if (op == '+' || op == '-') return 1;\n        if (op == '' || op == '/') return 2;\n        return 0;\n    }\n\n    public static String infixToPrefix(String expr) {\n        // Reverse the infix expression\n        StringBuilder input = new StringBuilder(expr).reverse();\n        Stack<Character> operators = new Stack<>();\n        Stack<String> operands = new Stack<>();\n\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n\n            if (Character.isLetterOrDigit(c)) {\n                operands.push(c + \"\");\n            } else if (c == ')') {\n                operators.push(c);\n            } else if (c == '(') {\n                while (!operators.isEmpty() && operators.peek() != ')') {\n                    String op1 = operands.pop();\n                    String op2 = operands.pop();\n                    char op = operators.pop();\n                    operands.push(op + op2 + op1);\n                }\n                operators.pop(); // pop ')'\n            } else {\n                while (!operators.isEmpty() && precedence(c) < precedence(operators.peek())) {\n                    String op1 = operands.pop();\n                    String op2 = operands.pop();\n                    char op = operators.pop();\n                    operands.push(op + op2 + op1);\n                }\n                operators.push(c);\n            }\n        }\n\n        while (!operators.isEmpty()) {\n            String op1 = operands.pop();\n            String op2 = operands.pop();\n            char op = operators.pop();\n            operands.push(op + op2 + op1);\n        }\n\n        return operands.pop();\n    }\n\n    public static void main(String[] args) {\n        String expr = \"a+b*(c-d)\";\n        System.out.println(\"Prefix: \" + infixToPrefix(expr));\n    }\n}\n",
    "input": "\"a+b*(c-d)\"",
    "output": "\"+a*b c d-\"",
    "explanation": "We reverse the infix, use two stacks for operators and operands, and construct prefix by combining operands and operators, then reverse the result logically to obtain correct prefix notation."
  },
  {
    "question": "Convert a postfix expression (like 'abcd-+') to prefix notation (like '+a b c-d') using a stack. Use stack operations to build the prefix expression efficiently.",
    "answer": "import java.util.;\n\npublic class PostfixToPrefix {\n    public static String postfixToPrefix(String expr) {\n        Stack<String> stack = new Stack<>();\n\n        for (char c : expr.toCharArray()) {\n            if (Character.isLetterOrDigit(c)) {\n                stack.push(c + \"\");\n            } else {\n                String op2 = stack.pop();\n                String op1 = stack.pop();\n                stack.push(c + op1 + op2);\n            }\n        }\n\n        return stack.pop();\n    }\n\n    public static void main(String[] args) {\n        String expr = \"abcd-+\";\n        System.out.println(\"Prefix: \" + postfixToPrefix(expr));\n    }\n}\n",
    "input": "\"abcd-*+\"",
    "output": "\"+a*b c d-\"",
    "explanation": "We use a stack to store operands as strings. When an operator is encountered, we pop two operands, combine them with the operator at the beginning, and push back the result to get prefix notation."
  },
  {
    "question": "Given an array representing the heights of bars in a histogram, find the area of the largest rectangle that can be formed in the histogram. Use a stack to compute the maximum area efficiently in linear time.",
    "answer": "import java.util.*;\n\npublic class LargestRectangleHistogram {\n    public static int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n\n        for (int i = 0; i <= n; i++) {\n            int h = (i == n) ? 0 : heights[i];\n            while (!stack.isEmpty() && h < heights[stack.peek()]) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {2, 1, 5, 6, 2, 3};\n        System.out.println(\"Maximum rectangle area: \" + largestRectangleArea(heights));\n    }\n}\n",
    "input": "[2, 1, 5, 6, 2, 3]",
    "output": "10",
    "explanation": "We use a stack to keep indices of bars. For each bar, if it is smaller than the top of the stack, we pop from stack and calculate area considering popped bar as the smallest height. This ensures linear time computation."
  },
  {
    "question": "Given a binary matrix, find the area of the largest rectangle containing only 1's. Convert each row to a histogram and use a stack-based approach for maximum rectangle in histogram.",
    "answer": "import java.util.*;\n\npublic class MaximalRectangle {\n    public static int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int n = matrix[0].length;\n        int[] heights = new int[n];\n        int maxArea = 0;\n\n        for (char[] row : matrix) {\n            for (int i = 0; i < n; i++) {\n                heights[i] = row[i] == '1' ? heights[i] + 1 : 0;\n            }\n            maxArea = Math.max(maxArea, largestRectangleArea(heights));\n        }\n\n        return maxArea;\n    }\n\n    private static int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int n = heights.length;\n\n        for (int i = 0; i <= n; i++) {\n            int h = (i == n) ? 0 : heights[i];\n            while (!stack.isEmpty() && h < heights[stack.peek()]) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n\n    public static void main(String[] args) {\n        char[][] matrix = {\n            {'1','0','1','0','0'},\n            {'1','0','1','1','1'},\n            {'1','1','1','1','1'},\n            {'1','0','0','1','0'}\n        };\n        System.out.println(\"Maximal rectangle area: \" + maximalRectangle(matrix));\n    }\n}\n",
    "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
    "output": "6",
    "explanation": "We treat each row as a histogram by accumulating consecutive 1's. Then, we apply the stack-based largest rectangle in histogram method to each row to find the maximal rectangle."
  },
  {
    "question": "Given a string containing only '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Use a stack to track indices of unmatched parentheses efficiently.",
    "answer": "import java.util.*;\n\npublic class LongestValidParentheses {\n    public static int longestValidParentheses(String s) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        int maxLen = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxLen = Math.max(maxLen, i - stack.peek());\n                }\n            }\n        }\n\n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        String s = \"(()())\";\n        System.out.println(\"Longest valid parentheses length: \" + longestValidParentheses(s));\n    }\n}\n",
    "input": "\"(()())\"",
    "output": "6",
    "explanation": "We use a stack to store indices of unmatched '(' characters and a sentinel -1. For each ')', we pop and calculate the valid substring length based on current index and stack top."
  },
  {
    "question": "Given an array of non-negative integers representing elevation heights, compute how much water it can trap after raining. Use a stack to efficiently find previous bars for water trapping calculation.",
    "answer": "import java.util.*;\n\npublic class TrappingRainWater {\n    public static int trap(int[] height) {\n        Stack<Integer> stack = new Stack<>();\n        int water = 0, current = 0;\n\n        while (current < height.length) {\n            while (!stack.isEmpty() && height[current] > height[stack.peek()]) {\n                int top = stack.pop();\n                if (stack.isEmpty()) break;\n                int distance = current - stack.peek() - 1;\n                int boundedHeight = Math.min(height[current], height[stack.peek()]) - height[top];\n                water += distance * boundedHeight;\n            }\n            stack.push(current++);\n        }\n\n        return water;\n    }\n\n    public static void main(String[] args) {\n        int[] height = {0,1,0,2,1,0,1,3,2,1,2,1};\n        System.out.println(\"Trapped rain water: \" + trap(height));\n    }\n}\n",
    "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
    "output": "6",
    "explanation": "We use a stack to keep indices of bars. When a taller bar is found, we pop bars and calculate trapped water between the current bar and the stack top, using distance and bounded height."
  }
]